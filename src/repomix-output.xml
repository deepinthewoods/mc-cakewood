This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T08:50:34.180Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/cakewood/CakeWoodClient.java
client/java/ninja/trek/cakewood/mixin/client/ExampleClientMixin.java
client/resources/cakewood.client.mixins.json
main/java/ninja/trek/cakewood/CakeWood.java
main/java/ninja/trek/cakewood/CakeWoodBlock.java
main/java/ninja/trek/cakewood/CakeWoodClient.java
main/java/ninja/trek/cakewood/CakeWoodDataGenerator.java
main/java/ninja/trek/cakewood/CakeWoodRegistry.java
main/java/ninja/trek/cakewood/CornerCakeWoodBlock.java
main/java/ninja/trek/cakewood/mixin/ExampleMixin.java
main/repomix-output.xml
main/repomixx - dontignore.bat
main/repomixx.bat
main/resources/assets/cakewood/lang/en_us.json
main/resources/assets/cakewood/models/item/cake_wood_item.json
main/resources/cakewood.mixins.json
main/resources/fabric.mod.json
repomixx - dontignore.bat
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/cakewood/CakeWoodClient.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ClientModInitializer;
public class CakeWoodClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		// This entrypoint is suitable for setting up client-specific logic, such as rendering.
	}
}
</file>

<file path="client/java/ninja/trek/cakewood/mixin/client/ExampleClientMixin.java">
package ninja.trek.cakewood.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/resources/cakewood.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.cakewood.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/cakewood/CakeWood.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ModInitializer;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class CakeWood implements ModInitializer {
    public static final String MOD_ID = "cakewood";
    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
    @Override
    public void onInitialize() {
        // Register all CakeWood variants
        CakeWoodRegistry.register();
        LOGGER.info("CakeWood Mod Initialized - Let them eat cake... wood!");
    }
    // Utility method to create identifiers for this mod
    public static Identifier id(String path) {
        return Identifier.of(MOD_ID, path);
    }
}
</file>

<file path="main/java/ninja/trek/cakewood/CakeWoodBlock.java">
package ninja.trek.cakewood;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemPlacementContext;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.state.property.IntProperty;
import net.minecraft.util.ActionResult;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.BlockView;
import net.minecraft.world.World;
import net.minecraft.world.event.GameEvent;
import net.minecraft.sound.SoundEvents;
import net.minecraft.sound.SoundCategory;
public class CakeWoodBlock extends Block {
    public static final int MAX_BITES = 8;
    public static final IntProperty TOP_BITES = IntProperty.of("top_bites", 0, MAX_BITES);
    public static final IntProperty BOTTOM_BITES = IntProperty.of("bottom_bites", 0, MAX_BITES);
    public static final DirectionProperty TOP_FACING = DirectionProperty.of("top_facing",
            Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);
    public static final DirectionProperty BOTTOM_FACING = DirectionProperty.of("bottom_facing",
            Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);
    public CakeWoodBlock(Settings settings) {
        super(settings);
        setDefaultState(getStateManager().getDefaultState()
                .with(TOP_BITES, 0)
                .with(BOTTOM_BITES, 0)
                .with(TOP_FACING, Direction.NORTH)
                .with(BOTTOM_FACING, Direction.NORTH));
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(TOP_BITES, BOTTOM_BITES, TOP_FACING, BOTTOM_FACING);
    }
    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        Direction topFacing = state.get(TOP_FACING);
        Direction bottomFacing = state.get(BOTTOM_FACING);
        VoxelShape topShape = topBites >= MAX_BITES ? null : getHalfShape(topBites, true, topFacing);
        VoxelShape bottomShape = bottomBites >= MAX_BITES ? null : getHalfShape(bottomBites, false, bottomFacing);
        if (topShape == null && bottomShape == null) {
            return VoxelShapes.empty();
        } else if (topShape == null) {
            return bottomShape;
        } else if (bottomShape == null) {
            return topShape;
        }
        return VoxelShapes.union(topShape, bottomShape);
    }
    private VoxelShape getHalfShape(int bites, boolean isTop, Direction facing) {
        if (bites >= MAX_BITES) {
            return VoxelShapes.empty();
        }
        float biteSize = bites * 2.0f; // Each bite is 2 pixels deep
        float yMin = isTop ? 0.5f : 0f;
        float yMax = isTop ? 1.0f : 0.5f;
        return switch (facing) {
            case NORTH -> VoxelShapes.cuboid(
                    0.0f,                       // xMin
                    yMin,                       // yMin
                    0.0f + biteSize/16.0f,      // zMin (adjusted by bites)
                    1.0f,                       // xMax
                    yMax,                       // yMax
                    1.0f                        // zMax
            );
            case SOUTH -> VoxelShapes.cuboid(
                    0.0f,                       // xMin
                    yMin,                       // yMin
                    0.0f,                       // zMin
                    1.0f,                       // xMax
                    yMax,                       // yMax
                    1.0f - biteSize/16.0f       // zMax (adjusted by bites)
            );
            case WEST -> VoxelShapes.cuboid(
                    0.0f + biteSize/16.0f,      // xMin (adjusted by bites)
                    yMin,                       // yMin
                    0.0f,                       // zMin
                    1.0f,                       // xMax
                    yMax,                       // yMax
                    1.0f                        // zMax
            );
            case EAST -> VoxelShapes.cuboid(
                    0.0f,                       // xMin
                    yMin,                       // yMin
                    0.0f,                       // zMin
                    1.0f - biteSize/16.0f,      // xMax (adjusted by bites)
                    yMax,                       // yMax
                    1.0f                        // zMax
            );
            default -> VoxelShapes.cuboid(
                    0.0f, yMin, 0.0f,
                    1.0f, yMax, 1.0f
            );
        };
    }
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit) {
        if (world.isClient) {
            if (eatCakeWood(world, pos, state, player, hit).isAccepted()) {
                return ActionResult.SUCCESS;
            }
            return ActionResult.CONSUME;
        }
        return eatCakeWood(world, pos, state, player, hit);
    }
    private ActionResult eatCakeWood(World world, BlockPos pos, BlockState state, PlayerEntity player, BlockHitResult hit) {
        if (!player.canConsume(true)) {
            return ActionResult.PASS;
        }
        Vec3d hitPos = hit.getPos().subtract(pos.getX(), pos.getY(), pos.getZ());
        boolean isTopHalf = hitPos.y >= 0.5;
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        Direction topFacing = state.get(TOP_FACING);
        Direction bottomFacing = state.get(BOTTOM_FACING);
        if (isTopHalf) {
            if (!doesPointIntersectHalf(hitPos, topBites, true, topFacing)) {
                if (doesPointIntersectHalf(hitPos, bottomBites, false, bottomFacing)) {
                    isTopHalf = false;
                } else {
                    return ActionResult.PASS;
                }
            }
        } else {
            if (!doesPointIntersectHalf(hitPos, bottomBites, false, bottomFacing)) {
                return ActionResult.PASS;
            }
        }
        IntProperty bitesProp = isTopHalf ? TOP_BITES : BOTTOM_BITES;
        DirectionProperty facingProp = isTopHalf ? TOP_FACING : BOTTOM_FACING;
        int bites = state.get(bitesProp);
        if (bites >= MAX_BITES) {
            return ActionResult.PASS;
        }
        Direction facing = bites == 0
                ? Direction.fromHorizontal((int)((player.getYaw() * 4.0f / 360.0f) + 2.5f) & 3)
                : state.get(facingProp);
        BlockState newState = state.with(bitesProp, bites + 1)
                .with(facingProp, facing);
        world.setBlockState(pos, newState,
                Block.NOTIFY_ALL | Block.REDRAW_ON_MAIN_THREAD | Block.FORCE_STATE);
        if (newState.get(TOP_BITES) >= MAX_BITES &&
                newState.get(BOTTOM_BITES) >= MAX_BITES) {
            world.removeBlock(pos, false);
            world.emitGameEvent(player, GameEvent.BLOCK_DESTROY, pos);
        } else {
            world.emitGameEvent(player, GameEvent.BLOCK_CHANGE, pos);
        }
        player.getHungerManager().add(2, 0.1F);
        world.playSound(null, pos,
                SoundEvents.ENTITY_GENERIC_EAT,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        world.playSound(null, pos,
                SoundEvents.BLOCK_WOOD_BREAK,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        return ActionResult.SUCCESS;
    }
    private boolean doesPointIntersectHalf(Vec3d point, int bites, boolean isTop, Direction facing) {
        if (bites >= MAX_BITES) {
            return false;
        }
        double yMin = isTop ? 0.5 : 0.0;
        double yMax = isTop ? 1.0 : 0.5;
        if (point.y < yMin || point.y > yMax) {
            return false;
        }
        double biteDepth = bites * (2.0/16.0);
        return switch (facing) {
            case NORTH -> point.z >= biteDepth;
            case SOUTH -> point.z <= (1.0 - biteDepth);
            case WEST -> point.x >= biteDepth;
            case EAST -> point.x <= (1.0 - biteDepth);
            default -> true;
        };
    }
    @Override
    public BlockState getPlacementState(ItemPlacementContext ctx) {
        return getDefaultState()
                .with(TOP_FACING, ctx.getHorizontalPlayerFacing().getOpposite())
                .with(BOTTOM_FACING, ctx.getHorizontalPlayerFacing().getOpposite());
    }
    @Override
    public boolean hasComparatorOutput(BlockState state) {
        return true;
    }
    @Override
    public int getComparatorOutput(BlockState state, World world, BlockPos pos) {
        return Math.max(MAX_BITES - state.get(TOP_BITES), MAX_BITES - state.get(BOTTOM_BITES));
    }
}
</file>

<file path="main/java/ninja/trek/cakewood/CakeWoodClient.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ClientModInitializer;
public class CakeWoodClient implements ClientModInitializer {
    @Override
    public void onInitializeClient() {
        // Register client-side rendering and other client-specific features here
        CakeWood.LOGGER.info("CakeWood Client Initialized");
    }
}
</file>

<file path="main/java/ninja/trek/cakewood/CakeWoodDataGenerator.java">
package ninja.trek.cakewood;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.fabricmc.fabric.api.datagen.v1.provider.FabricModelProvider;
import net.minecraft.data.client.*;
import net.minecraft.item.BlockItem;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.Direction;
import java.util.*;
import java.util.function.BiFunction;
import static ninja.trek.cakewood.CakeWoodBlock.MAX_BITES;
public class CakeWoodDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        pack.addProvider(CakeWoodModelGenerator::new);
    }
    private static class CakeWoodModelGenerator extends FabricModelProvider {
        public CakeWoodModelGenerator(FabricDataOutput output) {
            super(output);
        }
        @Override
        public void generateBlockStateModels(BlockStateModelGenerator generator) {
            // Generate base CakeWood with custom texture
            generateVariantModel(generator,
                    CakeWoodRegistry.CAKE_WOOD_BLOCK,
                    "cake_wood",
                    "cake_wood");
            generateVariantModel(generator,
                    CakeWoodRegistry.CAKE_WOOD_PLANKS_BLOCK,
                    "cake_wood_planks",
                    "cake_wood_planks_base");
            // Generate base CornerCakeWood with custom texture
            generateCornerVariantModel(generator,
                    CakeWoodRegistry.CORNER_CAKE_WOOD_BLOCK,
                    "corner_cake_wood",
                    "cake_wood");
            generateCornerVariantModel(generator,
                    CakeWoodRegistry.CORNER_CAKE_WOOD_PLANKS_BLOCK,
                    "corner_cake_wood_planks",
                    "cake_wood_planks_base");
            // Generate veneered corner variants with proper textures
            for (Map.Entry<String, CornerCakeWoodBlock> entry : CakeWoodRegistry.getAllCornerWoodVariantBlocks().entrySet()) {
                String woodType = entry.getKey();
                String textureName = (woodType.equals("crimson") || woodType.equals("warped")) ?
                        woodType + "_stem" :
                        woodType + "_log";
                // Corner CakeWood variants
                generateCornerVariantModel(generator,
                        entry.getValue(),
                        woodType + "_veneered_corner_cake_wood",
                        textureName);
            }
            // Generate plank corner variants
            for (Map.Entry<String, CornerCakeWoodBlock> entry : CakeWoodRegistry.getAllCornerPlankVariantBlocks().entrySet()) {
                String woodType = entry.getKey();
                generateCornerVariantModel(generator,
                        entry.getValue(),
                        woodType + "_veneered_corner_cake_wood_planks",
                        woodType + "_planks");
            }
            // Generate veneered variants
            for (Map.Entry<String, CakeWoodBlock> entry : CakeWoodRegistry.getAllWoodVariantBlocks().entrySet()) {
                String woodType = entry.getKey();
                String textureName = (woodType.equals("crimson") || woodType.equals("warped")) ?
                        woodType + "_stem" :
                        woodType + "_log";
                // Regular CakeWood variants
                generateVariantModel(generator,
                        entry.getValue(),
                        woodType + "_veneered_cake_wood",
                        textureName);
                generateVariantModel(generator,
                        CakeWoodRegistry.getPlankVariantBlock(woodType),
                        woodType + "_veneered_cake_wood_planks",
                        woodType + "_planks");
            }
        }
        @Override
        public void generateItemModels(ItemModelGenerator generator) {
            // Base variants
            generateItemModel(generator, CakeWoodRegistry.CAKE_WOOD_ITEM, "cake_wood");
            generateItemModel(generator, CakeWoodRegistry.CAKE_WOOD_PLANKS_ITEM, "cake_wood_planks_base");
            generateCornerItemModel(generator, CakeWoodRegistry.CORNER_CAKE_WOOD_ITEM, "cake_wood");
            generateCornerItemModel(generator, CakeWoodRegistry.CORNER_CAKE_WOOD_PLANKS_ITEM, "cake_wood_planks_base");
            // Wood variants
            for (Map.Entry<String, BlockItem> entry : CakeWoodRegistry.getAllWoodVariantItems().entrySet()) {
                String woodType = entry.getKey();
                String woodTexture = (woodType.equals("crimson") || woodType.equals("warped")) ?
                        woodType + "_stem" : woodType + "_log";
                // Regular CakeWood items
                generateItemModel(generator, entry.getValue(), woodTexture);
                generateItemModel(generator,
                        CakeWoodRegistry.getPlankVariantItem(woodType),
                        woodType + "_planks");
                // Corner CakeWood items
                generateCornerItemModel(generator,
                        CakeWoodRegistry.getCornerWoodVariantItem(woodType),
                        woodTexture);
                generateCornerItemModel(generator,
                        CakeWoodRegistry.getCornerPlankVariantItem(woodType),
                        woodType + "_planks");
            }
        }
        private void generateItemModel(ItemModelGenerator generator, BlockItem item, String textureId) {
            String textureRef = "minecraft:block/" + textureId;
            if (textureId.startsWith("cake_wood")) {
                textureRef = CakeWood.MOD_ID + ":block/" + textureId;
            }
            Model bittenModel = createBittenModel();
            bittenModel.upload(
                    ModelIds.getItemModelId(item),
                    TextureMap.all(Identifier.of(
                            textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                            "block/" + textureId)),
                    generator.writer
            );
        }
        private Model createBittenModel() {
            return new Model(Optional.empty(), Optional.empty(), TextureKey.ALL) {
                @Override
                public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                    JsonObject json = new JsonObject();
                    json.addProperty("parent", "minecraft:block/block");
                    JsonObject texturesJson = new JsonObject();
                    texturesJson.addProperty("all", textures.get(TextureKey.ALL).toString());
                    texturesJson.addProperty("particle", textures.get(TextureKey.ALL).toString());
                    json.add("textures", texturesJson);
                    JsonArray elements = new JsonArray();
                    // Top half - with bite on south side
                    elements.add(createCuboid(1, 8, 1, 15, 16, 13));
                    // Bottom half - with one bite
                    elements.add(createCuboid(1, 0, 3, 15, 8, 15));
                    json.add("elements", elements);
                    return json;
                }
                private JsonObject createCuboid(int fromX, int fromY, int fromZ, int toX, int toY, int toZ) {
                    JsonObject element = new JsonObject();
                    JsonArray from = new JsonArray();
                    from.add(fromX);
                    from.add(fromY);
                    from.add(fromZ);
                    element.add("from", from);
                    JsonArray to = new JsonArray();
                    to.add(toX);
                    to.add(toY);
                    to.add(toZ);
                    element.add("to", to);
                    JsonObject faces = new JsonObject();
                    for (String face : new String[]{"north", "south", "east", "west", "up", "down"}) {
                        JsonObject faceObj = new JsonObject();
                        faceObj.addProperty("texture", "#all");
                        faces.add(face, faceObj);
                    }
                    element.add("faces", faces);
                    return element;
                }
            };
        }
        private void generateVariantModel(BlockStateModelGenerator generator,
                                          CakeWoodBlock block,
                                          String variantName,
                                          String textureId) {
            LOGGER.info("var model " + variantName);
            MultipartBlockStateSupplier stateSupplier = MultipartBlockStateSupplier.create(block);
            TextureKey WOOD_TEXTURE = TextureKey.of("wood_texture");
            for (int bites = 0; bites < CakeWoodBlock.MAX_BITES; bites++) {
                final int bitesValue = bites;
                for (boolean isTop : Arrays.asList(true, false)) {
                    String modelName = String.format("block/%s_%s_%d",
                            variantName,
                            isTop ? "top" : "bottom",
                            bites);
                    Model model = new Model(
                            Optional.of(Identifier.of(CakeWood.MOD_ID, "block/cake_wood_template")),
                            Optional.empty(),
                            WOOD_TEXTURE
                    ) {
                        @Override
                        public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                            JsonObject json = new JsonObject();
                            json.addProperty("parent", "minecraft:block/block");
                            JsonObject texturesJson = new JsonObject();
                            String textureRef = "minecraft:block/" + textureId;
                            if (textureId.startsWith("cake_wood")) {
                                textureRef = CakeWood.MOD_ID + ":block/" + textureId;
                            }
                            texturesJson.addProperty("wood_texture", textureRef);
                            texturesJson.addProperty("particle", textureRef);
                            json.add("textures", texturesJson);
                            float biteSize = bitesValue * (16.0f / CakeWoodBlock.MAX_BITES);
                            float depth = 16 - biteSize;
                            int yOffset = isTop ? 8 : 0;
                            int height = 8;
                            JsonArray elements = new JsonArray();
                            JsonObject element = new JsonObject();
                            JsonArray from = new JsonArray();
                            from.add(0);
                            from.add(yOffset);
                            from.add(0);
                            element.add("from", from);
                            JsonArray to = new JsonArray();
                            to.add(16);
                            to.add(yOffset + height);
                            to.add(depth);
                            element.add("to", to);
                            JsonObject faces = new JsonObject();
                            BiFunction<Integer, Integer, JsonObject> createFace = (startV, endV) -> {
                                JsonObject face = new JsonObject();
                                face.addProperty("texture", "#wood_texture");
                                JsonArray uv = new JsonArray();
                                uv.add(0);
                                uv.add(startV);
                                uv.add(16);
                                uv.add(endV);
                                face.add("uv", uv);
                                return face;
                            };
                            faces.add("north", createFace.apply(16-height, 16));
                            faces.add("south", createFace.apply(16-height, 16));
                            faces.add("east", createFace.apply(16-height, 16));
                            faces.add("west", createFace.apply(16-height, 16));
                            faces.add("up", createFace.apply(0, (int)depth));
                            faces.add("down", createFace.apply(0, (int)depth));
                            element.add("faces", faces);
                            elements.add(element);
                            json.add("elements", elements);
                            return json;
                        }
                    };
                    TextureMap textureMap = new TextureMap()
                            .put(WOOD_TEXTURE, Identifier.of(
                                    textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                                    "block/" + textureId));
                    Identifier modelId = model.upload(
                            Identifier.of(CakeWood.MOD_ID, modelName),
                            textureMap,
                            generator.modelCollector
                    );
                    for (Direction facing : Direction.Type.HORIZONTAL) {
                        When condition = When.create()
                                .set(isTop ? CakeWoodBlock.TOP_BITES : CakeWoodBlock.BOTTOM_BITES, bitesValue)
                                .set(isTop ? CakeWoodBlock.TOP_FACING : CakeWoodBlock.BOTTOM_FACING, facing);
                        stateSupplier.with(condition, BlockStateVariant.create()
                                .put(VariantSettings.MODEL, modelId)
                                .put(VariantSettings.Y, VariantSettings.Rotation.values()
                                        [(int) (facing.asRotation() / 90.0f)])
                        );
                    }
                }
            }
            generator.blockStateCollector.accept(stateSupplier);
        }
        private void generateCornerItemModel(ItemModelGenerator generator, BlockItem item, String textureId) {
            String textureRef = "minecraft:block/" + textureId;
            if (textureId.startsWith("cake_wood")) {
                textureRef = CakeWood.MOD_ID + ":block/" + textureId;
            }
            Model cornerModel = new Model(Optional.empty(), Optional.empty(), TextureKey.ALL) {
                @Override
                public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                    JsonObject json = new JsonObject();
                    json.addProperty("parent", "minecraft:block/block");
                    JsonObject texturesJson = new JsonObject();
                    texturesJson.addProperty("all", textures.get(TextureKey.ALL).toString());
                    texturesJson.addProperty("particle", textures.get(TextureKey.ALL).toString());
                    json.add("textures", texturesJson);
                    JsonArray elements = new JsonArray();
                    // Bottom half - full size southwest corner
                    elements.add(createCornerElement(0, 8, true));
                    // Top half - half size southwest corner (showing 4 bites taken)
                    elements.add(createCornerElement(8, 16, false));
                    json.add("elements", elements);
                    return json;
                }
                private JsonObject createCornerElement(int yMin, int yMax, boolean isFullSize) {
                    JsonObject element = new JsonObject();
                    int size = isFullSize ? 16 : 8; // 16 for bottom, 8 for bitten top
                    // For southwest corner, we want to start at x=0, but end at maxZ
                    JsonArray from = new JsonArray();
                    from.add(0);                    // x starts at 0
                    from.add(yMin);                 // y
                    from.add(16 - size);            // z starts offset from back for the given size
                    element.add("from", from);
                    JsonArray to = new JsonArray();
                    to.add(size);                   // x extends by size
                    to.add(yMax);                   // y
                    to.add(16);                     // z goes to full depth
                    element.add("to", to);
                    // Add faces with proper UV mapping
                    JsonObject faces = new JsonObject();
                    String[] faceNames = {"north", "south", "east", "west", "up", "down"};
                    for (String face : faceNames) {
                        JsonObject faceObj = new JsonObject();
                        faceObj.addProperty("texture", "#all");
                        JsonArray uv = new JsonArray();
                        switch (face) {
                            case "up", "down" -> {
                                uv.add(0);
                                uv.add(16 - size);
                                uv.add(size);
                                uv.add(16);
                            }
                            case "north", "south" -> {
                                uv.add(0);
                                uv.add(yMin);
                                uv.add(size);
                                uv.add(yMax);
                            }
                            case "east", "west" -> {
                                uv.add(16 - size);
                                uv.add(yMin);
                                uv.add(16);
                                uv.add(yMax);
                            }
                        }
                        faceObj.add("uv", uv);
                        faces.add(face, faceObj);
                    }
                    element.add("faces", faces);
                    return element;
                }
            };
            cornerModel.upload(
                    ModelIds.getItemModelId(item),
                    TextureMap.all(Identifier.of(
                            textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                            "block/" + textureId)),
                    generator.writer
            );
        }
        // Update the generateCornerVariantModel method in CakeWoodDataGenerator.java
        private void generateCornerVariantModel(BlockStateModelGenerator generator,
                                                CornerCakeWoodBlock block,
                                                String variantName,
                                                String textureId) {
            LOGGER.info("corner var " + variantName);
            // Create a single MultipartBlockStateSupplier for the block
            MultipartBlockStateSupplier stateSupplier = MultipartBlockStateSupplier.create(block);
            TextureKey ALL = TextureKey.of("all");
            // Generate models for all combinations of bites and directions
            for (int bites = 0; bites < CornerCakeWoodBlock.MAX_BITES; bites++) {
                final int bitesValue = bites;
                for (boolean isTop : Arrays.asList(true, false)) {
                    for (CornerCakeWoodBlock.DiagonalDirection facing : CornerCakeWoodBlock.DiagonalDirection.values()) {
                        // Create a unique model name for each combination
                        String modelName = String.format("block/%s_%s_%d_%s",
                                variantName,
                                isTop ? "top" : "bottom",
                                bites,
                                facing.asString());
                        Model model = new Model(Optional.empty(), Optional.empty(), ALL) {
                            @Override
                            public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                                JsonObject json = new JsonObject();
                                json.addProperty("parent", "minecraft:block/block");
                                JsonObject texturesJson = new JsonObject();
                                texturesJson.addProperty("particle", textures.get(ALL).toString());
                                texturesJson.addProperty("texture", textures.get(ALL).toString());
                                json.add("textures", texturesJson);
                                float size = 16.0f - (bitesValue * (16.0f / CornerCakeWoodBlock.MAX_BITES));
                                float yMin = isTop ? 8.0f : 0.0f;
                                float yMax = isTop ? 16.0f : 8.0f;
                                float xFrom, xTo, zFrom, zTo;
                                switch (facing) {
                                    case NORTHWEST:
                                        xFrom = 0; xTo = size; zFrom = 0; zTo = size;
                                        break;
                                    case NORTHEAST:
                                        xFrom = 16 - size; xTo = 16; zFrom = 0; zTo = size;
                                        break;
                                    case SOUTHEAST:
                                        xFrom = 16 - size; xTo = 16; zFrom = 16 - size; zTo = 16;
                                        break;
                                    case SOUTHWEST:
                                        xFrom = 0; xTo = size; zFrom = 16 - size; zTo = 16;
                                        break;
                                    default:
                                        xFrom = 0; xTo = size; zFrom = 0; zTo = size;
                                        break;
                                }
                                JsonArray elements = new JsonArray();
                                JsonObject element = new JsonObject();
                                JsonArray from = new JsonArray();
                                from.add(xFrom);
                                from.add(yMin);
                                from.add(zFrom);
                                element.add("from", from);
                                JsonArray to = new JsonArray();
                                to.add(xTo);
                                to.add(yMax);
                                to.add(zTo);
                                element.add("to", to);
                                JsonObject faces = new JsonObject();
                                for (String face : new String[]{"north", "south", "east", "west", "up", "down"}) {
                                    JsonObject faceObj = new JsonObject();
                                    faceObj.addProperty("texture", "#texture");
                                    JsonArray uv = new JsonArray();
                                    if (face.equals("up") || face.equals("down")) {
                                        uv.add(xFrom);
                                        uv.add(zFrom);
                                        uv.add(xTo);
                                        uv.add(zTo);
                                    } else {
                                        uv.add(xFrom);
                                        uv.add(yMin);
                                        uv.add(xTo);
                                        uv.add(yMax);
                                    }
                                    faceObj.add("uv", uv);
                                    faces.add(face, faceObj);
                                }
                                element.add("faces", faces);
                                elements.add(element);
                                json.add("elements", elements);
                                return json;
                            }
                        };
                        TextureMap textureMap = new TextureMap().put(ALL, Identifier.of(
                                textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                                "block/" + textureId));
                        Identifier modelId = model.upload(
                                Identifier.of(CakeWood.MOD_ID, modelName),
                                textureMap,
                                generator.modelCollector
                        );
                        // Add this variant to the MultipartBlockStateSupplier
                        When condition = When.create()
                                .set(isTop ? CornerCakeWoodBlock.TOP_BITES : CornerCakeWoodBlock.BOTTOM_BITES, bitesValue)
                                .set(isTop ? CornerCakeWoodBlock.TOP_FACING : CornerCakeWoodBlock.BOTTOM_FACING, facing);
                        stateSupplier.with(condition, BlockStateVariant.create()
                                .put(VariantSettings.MODEL, modelId));
                    }
                }
            }
            // Register the blockstate once with all variants
            generator.blockStateCollector.accept(stateSupplier);
        }
    }
}
</file>

<file path="main/java/ninja/trek/cakewood/CakeWoodRegistry.java">
package ninja.trek.cakewood;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.minecraft.block.Block;
import net.minecraft.block.MapColor;
import net.minecraft.block.piston.PistonBehavior;
import net.minecraft.item.BlockItem;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.sound.BlockSoundGroup;
import net.minecraft.text.Text;
import java.util.HashMap;
import java.util.Map;
public class CakeWoodRegistry {
    // Base CakeWood blocks and items
    public static final CakeWoodBlock CAKE_WOOD_BLOCK = new CakeWoodBlock(createBlockSettings());
    public static final CakeWoodBlock CAKE_WOOD_PLANKS_BLOCK = new CakeWoodBlock(createBlockSettings());
    public static final BlockItem CAKE_WOOD_ITEM = createBlockItem(CAKE_WOOD_BLOCK, "block.cakewood.cake_wood");
    public static final BlockItem CAKE_WOOD_PLANKS_ITEM = createBlockItem(CAKE_WOOD_PLANKS_BLOCK, "block.cakewood.cake_wood_planks");
    // Base CornerCakeWood blocks and items
    public static final CornerCakeWoodBlock CORNER_CAKE_WOOD_BLOCK = new CornerCakeWoodBlock(createBlockSettings());
    public static final CornerCakeWoodBlock CORNER_CAKE_WOOD_PLANKS_BLOCK = new CornerCakeWoodBlock(createBlockSettings());
    public static final BlockItem CORNER_CAKE_WOOD_ITEM = createBlockItem(CORNER_CAKE_WOOD_BLOCK, "block.cakewood.corner_cake_wood");
    public static final BlockItem CORNER_CAKE_WOOD_PLANKS_ITEM = createBlockItem(CORNER_CAKE_WOOD_PLANKS_BLOCK, "block.cakewood.corner_cake_wood_planks");
    // Maps to store variants for CakeWood
    private static final Map<String, CakeWoodBlock> CAKE_WOOD_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CAKE_WOOD_VARIANT_ITEMS = new HashMap<>();
    private static final Map<String, CakeWoodBlock> CAKE_WOOD_PLANK_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CAKE_WOOD_PLANK_VARIANT_ITEMS = new HashMap<>();
    // Maps to store variants for CornerCakeWood
    private static final Map<String, CornerCakeWoodBlock> CORNER_CAKE_WOOD_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CORNER_CAKE_WOOD_VARIANT_ITEMS = new HashMap<>();
    private static final Map<String, CornerCakeWoodBlock> CORNER_CAKE_WOOD_PLANK_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS = new HashMap<>();
    private static FabricBlockSettings createBlockSettings() {
        return FabricBlockSettings.create()
                .mapColor(MapColor.BROWN)
                .strength(0.5f)
                .sounds(BlockSoundGroup.WOOD)
                .nonOpaque()
                .pistonBehavior(PistonBehavior.DESTROY)
                .breakInstantly();
    }
    private static BlockItem createBlockItem(Block block, String translationKey) {
        return new BlockItem(block, new Item.Settings()) {
            @Override
            public Text getName() {
                return Text.translatable(translationKey);
            }
        };
    }
    // Getter methods for CakeWood variants
    public static Map<String, CakeWoodBlock> getAllWoodVariantBlocks() {
        return CAKE_WOOD_VARIANTS;
    }
    public static Map<String, BlockItem> getAllWoodVariantItems() {
        return CAKE_WOOD_VARIANT_ITEMS;
    }
    public static Map<String, CakeWoodBlock> getAllPlankVariantBlocks() {
        return CAKE_WOOD_PLANK_VARIANTS;
    }
    public static Map<String, BlockItem> getAllPlankVariantItems() {
        return CAKE_WOOD_PLANK_VARIANT_ITEMS;
    }
    // Getter methods for CornerCakeWood variants
    public static Map<String, CornerCakeWoodBlock> getAllCornerWoodVariantBlocks() {
        return CORNER_CAKE_WOOD_VARIANTS;
    }
    public static Map<String, BlockItem> getAllCornerWoodVariantItems() {
        return CORNER_CAKE_WOOD_VARIANT_ITEMS;
    }
    public static Map<String, CornerCakeWoodBlock> getAllCornerPlankVariantBlocks() {
        return CORNER_CAKE_WOOD_PLANK_VARIANTS;
    }
    public static Map<String, BlockItem> getAllCornerPlankVariantItems() {
        return CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS;
    }
    public static void register() {
        // Register base CakeWood and CakeWood Planks
        Registry.register(Registries.BLOCK, CakeWood.id("cake_wood"), CAKE_WOOD_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("cake_wood"), CAKE_WOOD_ITEM);
        Registry.register(Registries.BLOCK, CakeWood.id("cake_wood_planks"), CAKE_WOOD_PLANKS_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("cake_wood_planks"), CAKE_WOOD_PLANKS_ITEM);
        // Register base CornerCakeWood and CornerCakeWood Planks
        Registry.register(Registries.BLOCK, CakeWood.id("corner_cake_wood"), CORNER_CAKE_WOOD_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("corner_cake_wood"), CORNER_CAKE_WOOD_ITEM);
        Registry.register(Registries.BLOCK, CakeWood.id("corner_cake_wood_planks"), CORNER_CAKE_WOOD_PLANKS_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("corner_cake_wood_planks"), CORNER_CAKE_WOOD_PLANKS_ITEM);
        // Register all wood variants
        registerVariant("oak", "Oak-Veneered");
        registerVariant("spruce", "Spruce-Veneered");
        registerVariant("birch", "Birch-Veneered");
        registerVariant("jungle", "Jungle-Veneered");
        registerVariant("acacia", "Acacia-Veneered");
        registerVariant("dark_oak", "Dark Oak-Veneered");
        registerVariant("mangrove", "Mangrove-Veneered");
        registerVariant("cherry", "Cherry-Veneered");
        registerVariant("bamboo", "Bamboo-Veneered");
        registerVariant("crimson", "Crimson-Veneered");
        registerVariant("warped", "Warped-Veneered");
    }
    private static void registerVariant(String woodType, String displayName) {
        // Create and register CakeWood variant
        CakeWoodBlock woodBlock = new CakeWoodBlock(createBlockSettings());
        CakeWoodBlock plankBlock = new CakeWoodBlock(createBlockSettings());
        String woodId = woodType + "_veneered_cake_wood";
        String plankId = woodType + "_veneered_cake_wood_planks";
        BlockItem woodItem = createBlockItem(woodBlock, "block.cakewood." + woodId);
        BlockItem plankItem = createBlockItem(plankBlock, "block.cakewood." + plankId);
        // Create and register CornerCakeWood variant
        CornerCakeWoodBlock cornerWoodBlock = new CornerCakeWoodBlock(createBlockSettings());
        CornerCakeWoodBlock cornerPlankBlock = new CornerCakeWoodBlock(createBlockSettings());
        String cornerWoodId = woodType + "_veneered_corner_cake_wood";
        String cornerPlankId = woodType + "_veneered_corner_cake_wood_planks";
        BlockItem cornerWoodItem = createBlockItem(cornerWoodBlock, "block.cakewood." + cornerWoodId);
        BlockItem cornerPlankItem = createBlockItem(cornerPlankBlock, "block.cakewood." + cornerPlankId);
        // Register CakeWood blocks and items
        Registry.register(Registries.BLOCK, CakeWood.id(woodId), woodBlock);
        Registry.register(Registries.ITEM, CakeWood.id(woodId), woodItem);
        Registry.register(Registries.BLOCK, CakeWood.id(plankId), plankBlock);
        Registry.register(Registries.ITEM, CakeWood.id(plankId), plankItem);
        // Register CornerCakeWood blocks and items
        Registry.register(Registries.BLOCK, CakeWood.id(cornerWoodId), cornerWoodBlock);
        Registry.register(Registries.ITEM, CakeWood.id(cornerWoodId), cornerWoodItem);
        Registry.register(Registries.BLOCK, CakeWood.id(cornerPlankId), cornerPlankBlock);
        Registry.register(Registries.ITEM, CakeWood.id(cornerPlankId), cornerPlankItem);
        // Store in maps
        CAKE_WOOD_VARIANTS.put(woodType, woodBlock);
        CAKE_WOOD_VARIANT_ITEMS.put(woodType, woodItem);
        CAKE_WOOD_PLANK_VARIANTS.put(woodType, plankBlock);
        CAKE_WOOD_PLANK_VARIANT_ITEMS.put(woodType, plankItem);
        CORNER_CAKE_WOOD_VARIANTS.put(woodType, cornerWoodBlock);
        CORNER_CAKE_WOOD_VARIANT_ITEMS.put(woodType, cornerWoodItem);
        CORNER_CAKE_WOOD_PLANK_VARIANTS.put(woodType, cornerPlankBlock);
        CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS.put(woodType, cornerPlankItem);
    }
    // Getter methods for specific variants
    public static CakeWoodBlock getWoodVariantBlock(String woodType) {
        return CAKE_WOOD_VARIANTS.get(woodType);
    }
    public static BlockItem getWoodVariantItem(String woodType) {
        return CAKE_WOOD_VARIANT_ITEMS.get(woodType);
    }
    public static CakeWoodBlock getPlankVariantBlock(String woodType) {
        return CAKE_WOOD_PLANK_VARIANTS.get(woodType);
    }
    public static BlockItem getPlankVariantItem(String woodType) {
        return CAKE_WOOD_PLANK_VARIANT_ITEMS.get(woodType);
    }
    public static CornerCakeWoodBlock getCornerWoodVariantBlock(String woodType) {
        return CORNER_CAKE_WOOD_VARIANTS.get(woodType);
    }
    public static BlockItem getCornerWoodVariantItem(String woodType) {
        return CORNER_CAKE_WOOD_VARIANT_ITEMS.get(woodType);
    }
    public static CornerCakeWoodBlock getCornerPlankVariantBlock(String woodType) {
        return CORNER_CAKE_WOOD_PLANK_VARIANTS.get(woodType);
    }
    public static BlockItem getCornerPlankVariantItem(String woodType) {
        return CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS.get(woodType);
    }
}
</file>

<file path="main/java/ninja/trek/cakewood/CornerCakeWoodBlock.java">
package ninja.trek.cakewood;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemPlacementContext;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.state.property.EnumProperty;
import net.minecraft.state.property.IntProperty;
import net.minecraft.util.ActionResult;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.BlockView;
import net.minecraft.world.World;
import net.minecraft.world.event.GameEvent;
import net.minecraft.sound.SoundEvents;
import net.minecraft.sound.SoundCategory;
import net.minecraft.util.StringIdentifiable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static ninja.trek.cakewood.CakeWood.MOD_ID;
public class CornerCakeWoodBlock extends Block {
    public static final int MAX_BITES = 8;
    public static final IntProperty TOP_BITES = IntProperty.of("top_bites", 0, MAX_BITES);
    public static final IntProperty BOTTOM_BITES = IntProperty.of("bottom_bites", 0, MAX_BITES);
//    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
    public enum DiagonalDirection implements StringIdentifiable {
        NORTHWEST("northwest"),
        NORTHEAST("northeast"),
        SOUTHWEST("southwest"),
        SOUTHEAST("southeast");
        private final String name;
        DiagonalDirection(String name) {
            this.name = name;
        }
        @Override
        public String asString() {
            return this.name;
        }
        public static DiagonalDirection fromPlayerView(PlayerEntity player, Vec3d hitPos) {
            float yaw = (player.getYaw() % 360 + 360 + 180 - 45) % 360;
            if (yaw >= 315 || yaw < 45) {
                // Player facing NE
                return DiagonalDirection.NORTHEAST;
            } else if (yaw >= 45 && yaw < 135) {
                // Player facing SE
                return DiagonalDirection.SOUTHEAST;
            } else if (yaw >= 135 && yaw < 225) {
                // Player facing SW
                return DiagonalDirection.SOUTHWEST;
            } else {
                // Player facing NW (yaw >= 225 && yaw < 315)
                return DiagonalDirection.NORTHWEST;
            }
        }
    }
    public static final EnumProperty<DiagonalDirection> TOP_FACING =
            EnumProperty.of("top_facing", DiagonalDirection.class);
    public static final EnumProperty<DiagonalDirection> BOTTOM_FACING =
            EnumProperty.of("bottom_facing", DiagonalDirection.class);
    public CornerCakeWoodBlock(Settings settings) {
        super(settings);
        setDefaultState(getStateManager().getDefaultState()
                .with(TOP_BITES, 0)
                .with(BOTTOM_BITES, 0)
                .with(TOP_FACING, DiagonalDirection.NORTHWEST)
                .with(BOTTOM_FACING, DiagonalDirection.NORTHWEST));
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(TOP_BITES, BOTTOM_BITES, TOP_FACING, BOTTOM_FACING);
    }
    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        DiagonalDirection topFacing = state.get(TOP_FACING);
        DiagonalDirection bottomFacing = state.get(BOTTOM_FACING);
        VoxelShape topShape = topBites >= MAX_BITES ? VoxelShapes.empty() :
                getHalfShape(topBites, true, topFacing);
        VoxelShape bottomShape = bottomBites >= MAX_BITES ? VoxelShapes.empty() :
                getHalfShape(bottomBites, false, bottomFacing);
        return VoxelShapes.union(topShape, bottomShape);
    }
    private VoxelShape getHalfShape(int bites, boolean isTop, DiagonalDirection facing) {
        if (bites >= MAX_BITES) {
            return VoxelShapes.empty();
        }
        // Compute how much of the block remains (using a 16pixel grid)
        float biteSize = bites * (16.0f / MAX_BITES);
        float size = 16.0f - biteSize; // in pixels
        float fraction = size / 16.0f; // normalized [0,1]
        float yMin = isTop ? 0.5f : 0.0f;
        float yMax = isTop ? 1.0f : 0.5f;
        return switch (facing) {
            case NORTHWEST -> VoxelShapes.cuboid(
                    0.0f, yMin, 0.0f,
                    fraction, yMax, fraction
            );
            case NORTHEAST -> VoxelShapes.cuboid(
                    1.0f - fraction, yMin, 0.0f,
                    1.0f, yMax, fraction
            );
            case SOUTHEAST -> VoxelShapes.cuboid(
                    1.0f - fraction, yMin, 1.0f - fraction,
                    1.0f, yMax, 1.0f
            );
            case SOUTHWEST -> VoxelShapes.cuboid(
                    0.0f, yMin, 1.0f - fraction,
                    fraction, yMax, 1.0f
            );
        };
    }
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit) {
        if (world.isClient) {
            if (eatCakeWood(world, pos, state, player, hit).isAccepted()) {
                return ActionResult.SUCCESS;
            }
            return ActionResult.CONSUME;
        }
        return eatCakeWood(world, pos, state, player, hit);
    }
    private ActionResult eatCakeWood(World world, BlockPos pos, BlockState state, PlayerEntity player, BlockHitResult hit) {
        if (!player.canConsume(true)) {
            return ActionResult.PASS;
        }
        Vec3d hitPos = hit.getPos().subtract(pos.getX(), pos.getY(), pos.getZ());
        boolean isTopHalf = hitPos.y >= 0.5;
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        DiagonalDirection topFacing = state.get(TOP_FACING);
        DiagonalDirection bottomFacing = state.get(BOTTOM_FACING);
        // Check if the hit position intersects with the remaining cake shape
        if (isTopHalf && !doesPointIntersectHalf(hitPos, topBites, true, topFacing)) {
            if (doesPointIntersectHalf(hitPos, bottomBites, false, bottomFacing)) {
                isTopHalf = false;
            } else {
                return ActionResult.PASS;
            }
        }
        IntProperty bitesProp = isTopHalf ? TOP_BITES : BOTTOM_BITES;
        EnumProperty<DiagonalDirection> facingProp = isTopHalf ? TOP_FACING : BOTTOM_FACING;
        int bites = state.get(bitesProp);
        if (bites >= MAX_BITES) {
            return ActionResult.PASS;
        }
        // Use the new direction logic for the first bite
        DiagonalDirection facing = bites == 0
                ? DiagonalDirection.fromPlayerView(player, hitPos)
                : state.get(facingProp);
//        LOGGER.info("facing " + facing);
        BlockState newState = state.with(bitesProp, bites + 1)
                .with(facingProp, facing);
        world.setBlockState(pos, newState,
                Block.NOTIFY_ALL | Block.REDRAW_ON_MAIN_THREAD | Block.FORCE_STATE);
        if (newState.get(TOP_BITES) >= MAX_BITES &&
                newState.get(BOTTOM_BITES) >= MAX_BITES) {
            world.removeBlock(pos, false);
            world.emitGameEvent(player, GameEvent.BLOCK_DESTROY, pos);
        } else {
            world.emitGameEvent(player, GameEvent.BLOCK_CHANGE, pos);
        }
        player.getHungerManager().add(2, 0.1F);
        // Play eating and breaking sounds
        world.playSound(null, pos,
                SoundEvents.ENTITY_GENERIC_EAT,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        world.playSound(null, pos,
                SoundEvents.BLOCK_WOOD_BREAK,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        return ActionResult.SUCCESS;
    }
    private boolean doesPointIntersectHalf(Vec3d point, int bites, boolean isTop, DiagonalDirection facing) {
        if (bites >= MAX_BITES) {
            return false;
        }
        double yMin = isTop ? 0.5 : 0.0;
        double yMax = isTop ? 1.0 : 0.5;
        if (point.y < yMin || point.y > yMax) {
            return false;
        }
        double fraction = 1.0 - ((double) bites / MAX_BITES);
        return switch (facing) {
            case NORTHWEST -> (point.x >= 0.0 && point.x <= fraction) &&
                    (point.z >= 0.0 && point.z <= fraction);
            case NORTHEAST -> (point.x >= 1.0 - fraction && point.x <= 1.0) &&
                    (point.z >= 0.0 && point.z <= fraction);
            case SOUTHEAST -> (point.x >= 1.0 - fraction && point.x <= 1.0) &&
                    (point.z >= 1.0 - fraction && point.z <= 1.0);
            case SOUTHWEST -> (point.x >= 0.0 && point.x <= fraction) &&
                    (point.z >= 1.0 - fraction && point.z <= 1.0);
        };
    }
    @Override
    public BlockState getPlacementState(ItemPlacementContext ctx) {
        // Just return default state - direction will be set on first bite
        return getDefaultState();
    }
    @Override
    public boolean hasComparatorOutput(BlockState state) {
        return true;
    }
    @Override
    public int getComparatorOutput(BlockState state, World world, BlockPos pos) {
        return Math.max(MAX_BITES - state.get(TOP_BITES), MAX_BITES - state.get(BOTTOM_BITES));
    }
}
</file>

<file path="main/java/ninja/trek/cakewood/mixin/ExampleMixin.java">
package ninja.trek.cakewood.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/repomix-output.xml">
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T08:19:18.585Z
<file_summary>
This section contains a summary of this file.
<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>
<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>
<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>
<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>
<additional_info>
</additional_info>
</file_summary>
<directory_structure>
java/ninja/trek/cakewood/CakeWood.java
java/ninja/trek/cakewood/CakeWoodBlock.java
java/ninja/trek/cakewood/CakeWoodClient.java
java/ninja/trek/cakewood/CakeWoodDataGenerator.java
java/ninja/trek/cakewood/CakeWoodRegistry.java
java/ninja/trek/cakewood/CornerCakeWoodBlock.java
java/ninja/trek/cakewood/mixin/ExampleMixin.java
repomixx - dontignore.bat
repomixx.bat
resources/assets/cakewood/lang/en_us.json
resources/assets/cakewood/models/item/cake_wood_item.json
resources/cakewood.mixins.json
resources/fabric.mod.json
</directory_structure>
<files>
This section contains the contents of the repository's files.
<file path="java/ninja/trek/cakewood/CakeWood.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ModInitializer;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class CakeWood implements ModInitializer {
    public static final String MOD_ID = "cakewood";
    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
    @Override
    public void onInitialize() {
        // Register all CakeWood variants
        CakeWoodRegistry.register();
        LOGGER.info("CakeWood Mod Initialized - Let them eat cake... wood!");
    }
    // Utility method to create identifiers for this mod
    public static Identifier id(String path) {
        return Identifier.of(MOD_ID, path);
    }
}
</file>
<file path="java/ninja/trek/cakewood/CakeWoodBlock.java">
package ninja.trek.cakewood;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemPlacementContext;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.state.property.IntProperty;
import net.minecraft.util.ActionResult;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.BlockView;
import net.minecraft.world.World;
import net.minecraft.world.event.GameEvent;
import net.minecraft.sound.SoundEvents;
import net.minecraft.sound.SoundCategory;
public class CakeWoodBlock extends Block {
    public static final int MAX_BITES = 8;
    public static final IntProperty TOP_BITES = IntProperty.of("top_bites", 0, MAX_BITES);
    public static final IntProperty BOTTOM_BITES = IntProperty.of("bottom_bites", 0, MAX_BITES);
    public static final DirectionProperty TOP_FACING = DirectionProperty.of("top_facing",
            Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);
    public static final DirectionProperty BOTTOM_FACING = DirectionProperty.of("bottom_facing",
            Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);
    public CakeWoodBlock(Settings settings) {
        super(settings);
        setDefaultState(getStateManager().getDefaultState()
                .with(TOP_BITES, 0)
                .with(BOTTOM_BITES, 0)
                .with(TOP_FACING, Direction.NORTH)
                .with(BOTTOM_FACING, Direction.NORTH));
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(TOP_BITES, BOTTOM_BITES, TOP_FACING, BOTTOM_FACING);
    }
    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        Direction topFacing = state.get(TOP_FACING);
        Direction bottomFacing = state.get(BOTTOM_FACING);
        VoxelShape topShape = topBites >= MAX_BITES ? null : getHalfShape(topBites, true, topFacing);
        VoxelShape bottomShape = bottomBites >= MAX_BITES ? null : getHalfShape(bottomBites, false, bottomFacing);
        if (topShape == null && bottomShape == null) {
            return VoxelShapes.empty();
        } else if (topShape == null) {
            return bottomShape;
        } else if (bottomShape == null) {
            return topShape;
        }
        return VoxelShapes.union(topShape, bottomShape);
    }
    private VoxelShape getHalfShape(int bites, boolean isTop, Direction facing) {
        if (bites >= MAX_BITES) {
            return VoxelShapes.empty();
        }
        float biteSize = bites * 2.0f; // Each bite is 2 pixels deep
        float yMin = isTop ? 0.5f : 0f;
        float yMax = isTop ? 1.0f : 0.5f;
        return switch (facing) {
            case NORTH -> VoxelShapes.cuboid(
                    0.0f,                       // xMin
                    yMin,                       // yMin
                    0.0f + biteSize/16.0f,      // zMin (adjusted by bites)
                    1.0f,                       // xMax
                    yMax,                       // yMax
                    1.0f                        // zMax
            );
            case SOUTH -> VoxelShapes.cuboid(
                    0.0f,                       // xMin
                    yMin,                       // yMin
                    0.0f,                       // zMin
                    1.0f,                       // xMax
                    yMax,                       // yMax
                    1.0f - biteSize/16.0f       // zMax (adjusted by bites)
            );
            case WEST -> VoxelShapes.cuboid(
                    0.0f + biteSize/16.0f,      // xMin (adjusted by bites)
                    yMin,                       // yMin
                    0.0f,                       // zMin
                    1.0f,                       // xMax
                    yMax,                       // yMax
                    1.0f                        // zMax
            );
            case EAST -> VoxelShapes.cuboid(
                    0.0f,                       // xMin
                    yMin,                       // yMin
                    0.0f,                       // zMin
                    1.0f - biteSize/16.0f,      // xMax (adjusted by bites)
                    yMax,                       // yMax
                    1.0f                        // zMax
            );
            default -> VoxelShapes.cuboid(
                    0.0f, yMin, 0.0f,
                    1.0f, yMax, 1.0f
            );
        };
    }
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit) {
        if (world.isClient) {
            if (eatCakeWood(world, pos, state, player, hit).isAccepted()) {
                return ActionResult.SUCCESS;
            }
            return ActionResult.CONSUME;
        }
        return eatCakeWood(world, pos, state, player, hit);
    }
    private ActionResult eatCakeWood(World world, BlockPos pos, BlockState state, PlayerEntity player, BlockHitResult hit) {
        if (!player.canConsume(true)) {
            return ActionResult.PASS;
        }
        Vec3d hitPos = hit.getPos().subtract(pos.getX(), pos.getY(), pos.getZ());
        boolean isTopHalf = hitPos.y >= 0.5;
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        Direction topFacing = state.get(TOP_FACING);
        Direction bottomFacing = state.get(BOTTOM_FACING);
        if (isTopHalf) {
            if (!doesPointIntersectHalf(hitPos, topBites, true, topFacing)) {
                if (doesPointIntersectHalf(hitPos, bottomBites, false, bottomFacing)) {
                    isTopHalf = false;
                } else {
                    return ActionResult.PASS;
                }
            }
        } else {
            if (!doesPointIntersectHalf(hitPos, bottomBites, false, bottomFacing)) {
                return ActionResult.PASS;
            }
        }
        IntProperty bitesProp = isTopHalf ? TOP_BITES : BOTTOM_BITES;
        DirectionProperty facingProp = isTopHalf ? TOP_FACING : BOTTOM_FACING;
        int bites = state.get(bitesProp);
        if (bites >= MAX_BITES) {
            return ActionResult.PASS;
        }
        Direction facing = bites == 0
                ? Direction.fromHorizontal((int)((player.getYaw() * 4.0f / 360.0f) + 2.5f) & 3)
                : state.get(facingProp);
        BlockState newState = state.with(bitesProp, bites + 1)
                .with(facingProp, facing);
        world.setBlockState(pos, newState,
                Block.NOTIFY_ALL | Block.REDRAW_ON_MAIN_THREAD | Block.FORCE_STATE);
        if (newState.get(TOP_BITES) >= MAX_BITES &&
                newState.get(BOTTOM_BITES) >= MAX_BITES) {
            world.removeBlock(pos, false);
            world.emitGameEvent(player, GameEvent.BLOCK_DESTROY, pos);
        } else {
            world.emitGameEvent(player, GameEvent.BLOCK_CHANGE, pos);
        }
        player.getHungerManager().add(2, 0.1F);
        world.playSound(null, pos,
                SoundEvents.ENTITY_GENERIC_EAT,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        world.playSound(null, pos,
                SoundEvents.BLOCK_WOOD_BREAK,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        return ActionResult.SUCCESS;
    }
    private boolean doesPointIntersectHalf(Vec3d point, int bites, boolean isTop, Direction facing) {
        if (bites >= MAX_BITES) {
            return false;
        }
        double yMin = isTop ? 0.5 : 0.0;
        double yMax = isTop ? 1.0 : 0.5;
        if (point.y < yMin || point.y > yMax) {
            return false;
        }
        double biteDepth = bites * (2.0/16.0);
        return switch (facing) {
            case NORTH -> point.z >= biteDepth;
            case SOUTH -> point.z <= (1.0 - biteDepth);
            case WEST -> point.x >= biteDepth;
            case EAST -> point.x <= (1.0 - biteDepth);
            default -> true;
        };
    }
    @Override
    public BlockState getPlacementState(ItemPlacementContext ctx) {
        return getDefaultState()
                .with(TOP_FACING, ctx.getHorizontalPlayerFacing().getOpposite())
                .with(BOTTOM_FACING, ctx.getHorizontalPlayerFacing().getOpposite());
    }
    @Override
    public boolean hasComparatorOutput(BlockState state) {
        return true;
    }
    @Override
    public int getComparatorOutput(BlockState state, World world, BlockPos pos) {
        return Math.max(MAX_BITES - state.get(TOP_BITES), MAX_BITES - state.get(BOTTOM_BITES));
    }
}
</file>
<file path="java/ninja/trek/cakewood/CakeWoodClient.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ClientModInitializer;
public class CakeWoodClient implements ClientModInitializer {
    @Override
    public void onInitializeClient() {
        // Register client-side rendering and other client-specific features here
        CakeWood.LOGGER.info("CakeWood Client Initialized");
    }
}
</file>
<file path="java/ninja/trek/cakewood/CakeWoodDataGenerator.java">
package ninja.trek.cakewood;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.fabricmc.fabric.api.datagen.v1.provider.FabricModelProvider;
import net.minecraft.data.client.*;
import net.minecraft.item.BlockItem;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.Direction;
import java.util.*;
import java.util.function.BiFunction;
import static ninja.trek.cakewood.CakeWoodBlock.MAX_BITES;
public class CakeWoodDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        pack.addProvider(CakeWoodModelGenerator::new);
    }
    private static class CakeWoodModelGenerator extends FabricModelProvider {
        public CakeWoodModelGenerator(FabricDataOutput output) {
            super(output);
        }
        @Override
        public void generateBlockStateModels(BlockStateModelGenerator generator) {
            // Generate base CakeWood with custom texture
            generateVariantModel(generator,
                    CakeWoodRegistry.CAKE_WOOD_BLOCK,
                    "cake_wood",
                    "cake_wood");
            generateVariantModel(generator,
                    CakeWoodRegistry.CAKE_WOOD_PLANKS_BLOCK,
                    "cake_wood_planks",
                    "cake_wood_planks_base");
            // Generate base CornerCakeWood with custom texture
            generateCornerVariantModel(generator,
                    CakeWoodRegistry.CORNER_CAKE_WOOD_BLOCK,
                    "corner_cake_wood",
                    "cake_wood");
            generateCornerVariantModel(generator,
                    CakeWoodRegistry.CORNER_CAKE_WOOD_PLANKS_BLOCK,
                    "corner_cake_wood_planks",
                    "cake_wood_planks_base");
            // Generate veneered corner variants with proper textures
            for (Map.Entry<String, CornerCakeWoodBlock> entry : CakeWoodRegistry.getAllCornerWoodVariantBlocks().entrySet()) {
                String woodType = entry.getKey();
                String textureName = (woodType.equals("crimson") || woodType.equals("warped")) ?
                        woodType + "_stem" :
                        woodType + "_log";
                // Corner CakeWood variants
                generateCornerVariantModel(generator,
                        entry.getValue(),
                        woodType + "_veneered_corner_cake_wood",
                        textureName);
            }
            // Generate plank corner variants
            for (Map.Entry<String, CornerCakeWoodBlock> entry : CakeWoodRegistry.getAllCornerPlankVariantBlocks().entrySet()) {
                String woodType = entry.getKey();
                generateCornerVariantModel(generator,
                        entry.getValue(),
                        woodType + "_veneered_corner_cake_wood_planks",
                        woodType + "_planks");
            }
            // Generate veneered variants
            for (Map.Entry<String, CakeWoodBlock> entry : CakeWoodRegistry.getAllWoodVariantBlocks().entrySet()) {
                String woodType = entry.getKey();
                String textureName = (woodType.equals("crimson") || woodType.equals("warped")) ?
                        woodType + "_stem" :
                        woodType + "_log";
                // Regular CakeWood variants
                generateVariantModel(generator,
                        entry.getValue(),
                        woodType + "_veneered_cake_wood",
                        textureName);
                generateVariantModel(generator,
                        CakeWoodRegistry.getPlankVariantBlock(woodType),
                        woodType + "_veneered_cake_wood_planks",
                        woodType + "_planks");
            }
        }
        @Override
        public void generateItemModels(ItemModelGenerator generator) {
            // Base variants
            generateItemModel(generator, CakeWoodRegistry.CAKE_WOOD_ITEM, "cake_wood");
            generateItemModel(generator, CakeWoodRegistry.CAKE_WOOD_PLANKS_ITEM, "cake_wood_planks_base");
            generateCornerItemModel(generator, CakeWoodRegistry.CORNER_CAKE_WOOD_ITEM, "cake_wood");
            generateCornerItemModel(generator, CakeWoodRegistry.CORNER_CAKE_WOOD_PLANKS_ITEM, "cake_wood_planks_base");
            // Wood variants
            for (Map.Entry<String, BlockItem> entry : CakeWoodRegistry.getAllWoodVariantItems().entrySet()) {
                String woodType = entry.getKey();
                String woodTexture = (woodType.equals("crimson") || woodType.equals("warped")) ?
                        woodType + "_stem" : woodType + "_log";
                // Regular CakeWood items
                generateItemModel(generator, entry.getValue(), woodTexture);
                generateItemModel(generator,
                        CakeWoodRegistry.getPlankVariantItem(woodType),
                        woodType + "_planks");
                // Corner CakeWood items
                generateCornerItemModel(generator,
                        CakeWoodRegistry.getCornerWoodVariantItem(woodType),
                        woodTexture);
                generateCornerItemModel(generator,
                        CakeWoodRegistry.getCornerPlankVariantItem(woodType),
                        woodType + "_planks");
            }
        }
        private void generateItemModel(ItemModelGenerator generator, BlockItem item, String textureId) {
            String textureRef = "minecraft:block/" + textureId;
            if (textureId.startsWith("cake_wood")) {
                textureRef = CakeWood.MOD_ID + ":block/" + textureId;
            }
            Model bittenModel = createBittenModel();
            bittenModel.upload(
                    ModelIds.getItemModelId(item),
                    TextureMap.all(Identifier.of(
                            textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                            "block/" + textureId)),
                    generator.writer
            );
        }
        private Model createBittenModel() {
            return new Model(Optional.empty(), Optional.empty(), TextureKey.ALL) {
                @Override
                public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                    JsonObject json = new JsonObject();
                    json.addProperty("parent", "minecraft:block/block");
                    JsonObject texturesJson = new JsonObject();
                    texturesJson.addProperty("all", textures.get(TextureKey.ALL).toString());
                    texturesJson.addProperty("particle", textures.get(TextureKey.ALL).toString());
                    json.add("textures", texturesJson);
                    JsonArray elements = new JsonArray();
                    // Top half - with bite on south side
                    elements.add(createCuboid(1, 8, 1, 15, 16, 13));
                    // Bottom half - with one bite
                    elements.add(createCuboid(1, 0, 3, 15, 8, 15));
                    json.add("elements", elements);
                    return json;
                }
                private JsonObject createCuboid(int fromX, int fromY, int fromZ, int toX, int toY, int toZ) {
                    JsonObject element = new JsonObject();
                    JsonArray from = new JsonArray();
                    from.add(fromX);
                    from.add(fromY);
                    from.add(fromZ);
                    element.add("from", from);
                    JsonArray to = new JsonArray();
                    to.add(toX);
                    to.add(toY);
                    to.add(toZ);
                    element.add("to", to);
                    JsonObject faces = new JsonObject();
                    for (String face : new String[]{"north", "south", "east", "west", "up", "down"}) {
                        JsonObject faceObj = new JsonObject();
                        faceObj.addProperty("texture", "#all");
                        faces.add(face, faceObj);
                    }
                    element.add("faces", faces);
                    return element;
                }
            };
        }
        private void generateVariantModel(BlockStateModelGenerator generator,
                                          CakeWoodBlock block,
                                          String variantName,
                                          String textureId) {
            LOGGER.info("var model " + variantName);
            MultipartBlockStateSupplier stateSupplier = MultipartBlockStateSupplier.create(block);
            TextureKey WOOD_TEXTURE = TextureKey.of("wood_texture");
            for (int bites = 0; bites < CakeWoodBlock.MAX_BITES; bites++) {
                final int bitesValue = bites;
                for (boolean isTop : Arrays.asList(true, false)) {
                    String modelName = String.format("block/%s_%s_%d",
                            variantName,
                            isTop ? "top" : "bottom",
                            bites);
                    Model model = new Model(
                            Optional.of(Identifier.of(CakeWood.MOD_ID, "block/cake_wood_template")),
                            Optional.empty(),
                            WOOD_TEXTURE
                    ) {
                        @Override
                        public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                            JsonObject json = new JsonObject();
                            json.addProperty("parent", "minecraft:block/block");
                            JsonObject texturesJson = new JsonObject();
                            String textureRef = "minecraft:block/" + textureId;
                            if (textureId.startsWith("cake_wood")) {
                                textureRef = CakeWood.MOD_ID + ":block/" + textureId;
                            }
                            texturesJson.addProperty("wood_texture", textureRef);
                            texturesJson.addProperty("particle", textureRef);
                            json.add("textures", texturesJson);
                            float biteSize = bitesValue * (16.0f / CakeWoodBlock.MAX_BITES);
                            float depth = 16 - biteSize;
                            int yOffset = isTop ? 8 : 0;
                            int height = 8;
                            JsonArray elements = new JsonArray();
                            JsonObject element = new JsonObject();
                            JsonArray from = new JsonArray();
                            from.add(0);
                            from.add(yOffset);
                            from.add(0);
                            element.add("from", from);
                            JsonArray to = new JsonArray();
                            to.add(16);
                            to.add(yOffset + height);
                            to.add(depth);
                            element.add("to", to);
                            JsonObject faces = new JsonObject();
                            BiFunction<Integer, Integer, JsonObject> createFace = (startV, endV) -> {
                                JsonObject face = new JsonObject();
                                face.addProperty("texture", "#wood_texture");
                                JsonArray uv = new JsonArray();
                                uv.add(0);
                                uv.add(startV);
                                uv.add(16);
                                uv.add(endV);
                                face.add("uv", uv);
                                return face;
                            };
                            faces.add("north", createFace.apply(16-height, 16));
                            faces.add("south", createFace.apply(16-height, 16));
                            faces.add("east", createFace.apply(16-height, 16));
                            faces.add("west", createFace.apply(16-height, 16));
                            faces.add("up", createFace.apply(0, (int)depth));
                            faces.add("down", createFace.apply(0, (int)depth));
                            element.add("faces", faces);
                            elements.add(element);
                            json.add("elements", elements);
                            return json;
                        }
                    };
                    TextureMap textureMap = new TextureMap()
                            .put(WOOD_TEXTURE, Identifier.of(
                                    textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                                    "block/" + textureId));
                    Identifier modelId = model.upload(
                            Identifier.of(CakeWood.MOD_ID, modelName),
                            textureMap,
                            generator.modelCollector
                    );
                    for (Direction facing : Direction.Type.HORIZONTAL) {
                        When condition = When.create()
                                .set(isTop ? CakeWoodBlock.TOP_BITES : CakeWoodBlock.BOTTOM_BITES, bitesValue)
                                .set(isTop ? CakeWoodBlock.TOP_FACING : CakeWoodBlock.BOTTOM_FACING, facing);
                        stateSupplier.with(condition, BlockStateVariant.create()
                                .put(VariantSettings.MODEL, modelId)
                                .put(VariantSettings.Y, VariantSettings.Rotation.values()
                                        [(int) (facing.asRotation() / 90.0f)])
                        );
                    }
                }
            }
            generator.blockStateCollector.accept(stateSupplier);
        }
        private void generateCornerItemModel(ItemModelGenerator generator, BlockItem item, String textureId) {
            String textureRef = "minecraft:block/" + textureId;
            if (textureId.startsWith("cake_wood")) {
                textureRef = CakeWood.MOD_ID + ":block/" + textureId;
            }
            Model cornerModel = new Model(Optional.empty(), Optional.empty(), TextureKey.ALL) {
                @Override
                public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                    JsonObject json = new JsonObject();
                    json.addProperty("parent", "minecraft:block/block");
                    JsonObject texturesJson = new JsonObject();
                    texturesJson.addProperty("all", textures.get(TextureKey.ALL).toString());
                    texturesJson.addProperty("particle", textures.get(TextureKey.ALL).toString());
                    json.add("textures", texturesJson);
                    JsonArray elements = new JsonArray();
                    // Add corner shape for top half (northwest corner)
                    elements.add(createCornerElement(8, 16, 12));
                    // Add corner shape for bottom half (northwest corner)
                    elements.add(createCornerElement(0, 8, 12));
                    json.add("elements", elements);
                    return json;
                }
                private JsonObject createCornerElement(int yMin, int yMax, int size) {
                    JsonObject element = new JsonObject();
                    JsonArray from = new JsonArray();
                    from.add(0);
                    from.add(yMin);
                    from.add(0);
                    element.add("from", from);
                    JsonArray to = new JsonArray();
                    to.add(size);
                    to.add(yMax);
                    to.add(size);
                    element.add("to", to);
                    JsonObject faces = new JsonObject();
                    String[] faceNames = {"north", "south", "east", "west", "up", "down"};
                    for (String face : faceNames) {
                        JsonObject faceObj = new JsonObject();
                        faceObj.addProperty("texture", "#all");
                        JsonArray uv = new JsonArray();
                        switch (face) {
                            case "up", "down" -> {
                                uv.add(0);
                                uv.add(0);
                                uv.add(size);
                                uv.add(size);
                            }
                            default -> {
                                uv.add(0);
                                uv.add(yMin);
                                uv.add(size);
                                uv.add(yMax);
                            }
                        }
                        faceObj.add("uv", uv);
                        faces.add(face, faceObj);
                    }
                    element.add("faces", faces);
                    return element;
                }
            };
            cornerModel.upload(
                    ModelIds.getItemModelId(item),
                    TextureMap.all(Identifier.of(
                            textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                            "block/" + textureId)),
                    generator.writer
            );
        }
        private void generateCornerVariantModel(BlockStateModelGenerator generator,
                                                CornerCakeWoodBlock block,
                                                String variantName,
                                                String textureId) {
            LOGGER.info("corner var " + variantName);
            // For each diagonal direction, build a model that uses the correct corner geometry.
            for (CornerCakeWoodBlock.DiagonalDirection facing : CornerCakeWoodBlock.DiagonalDirection.values()) {
                MultipartBlockStateSupplier stateSupplier = MultipartBlockStateSupplier.create(block);
                TextureKey ALL = TextureKey.of("all");
                for (int bites = 0; bites < CornerCakeWoodBlock.MAX_BITES; bites++) {
                    final int bitesValue = bites;
                    for (boolean isTop : Arrays.asList(true, false)) {
                        // Create a unique model name per state (including the direction)
                        String modelName = String.format("block/%s_%s_%d_%s",
                                variantName,
                                isTop ? "top" : "bottom",
                                bites,
                                facing.asString());
                        Model model = new Model(Optional.empty(), Optional.empty(), ALL) {
                            @Override
                            public JsonObject createJson(Identifier id, Map<TextureKey, Identifier> textures) {
                                JsonObject json = new JsonObject();
                                json.addProperty("parent", "minecraft:block/block");
                                JsonObject texturesJson = new JsonObject();
                                texturesJson.addProperty("particle", textures.get(ALL).toString());
                                texturesJson.addProperty("texture", textures.get(ALL).toString());
                                json.add("textures", texturesJson);
                                // Compute the size (in pixels) from the number of bites
                                float size = 16.0f - (bitesValue * (16.0f / CornerCakeWoodBlock.MAX_BITES));
                                float yMin = isTop ? 8.0f : 0.0f;
                                float yMax = isTop ? 16.0f : 8.0f;
                                float xFrom, xTo, zFrom, zTo;
                                // Set from and to based on the desired corner.
                                switch (facing) {
                                    case NORTHWEST -> {
                                        xFrom = 0;
                                        xTo = size;
                                        zFrom = 0;
                                        zTo = size;
                                    }
                                    case NORTHEAST -> {
                                        xFrom = 16 - size;
                                        xTo = 16;
                                        zFrom = 0;
                                        zTo = size;
                                    }
                                    case SOUTHEAST -> {
                                        xFrom = 16 - size;
                                        xTo = 16;
                                        zFrom = 16 - size;
                                        zTo = 16;
                                    }
                                    case SOUTHWEST -> {
                                        xFrom = 0;
                                        xTo = size;
                                        zFrom = 16 - size;
                                        zTo = 16;
                                    }
                                    default -> {
                                        xFrom = 0; xTo = size; zFrom = 0; zTo = size;
                                    }
                                }
                                JsonArray elements = new JsonArray();
                                JsonObject element = new JsonObject();
                                JsonArray from = new JsonArray();
                                from.add(xFrom);
                                from.add(yMin);
                                from.add(zFrom);
                                element.add("from", from);
                                JsonArray to = new JsonArray();
                                to.add(xTo);
                                to.add(yMax);
                                to.add(zTo);
                                element.add("to", to);
                                // Define the faces (here we use a simple UV mapping that spans the element)
                                JsonObject faces = new JsonObject();
                                for (String face : new String[]{"north", "south", "east", "west", "up", "down"}) {
                                    JsonObject faceObj = new JsonObject();
                                    faceObj.addProperty("texture", "#texture");
                                    JsonArray uv = new JsonArray();
                                    // For the top and bottom faces, use X/Z coordinates;
                                    // for the sides, you may want to adjust as needed.
                                    if (face.equals("up") || face.equals("down")) {
                                        uv.add(xFrom);
                                        uv.add(zFrom);
                                        uv.add(xTo);
                                        uv.add(zTo);
                                    } else {
                                        uv.add(xFrom);
                                        uv.add(yMin);
                                        uv.add(xTo);
                                        uv.add(yMax);
                                    }
                                    faceObj.add("uv", uv);
                                    faces.add(face, faceObj);
                                }
                                element.add("faces", faces);
                                elements.add(element);
                                json.add("elements", elements);
                                return json;
                            }
                        };
                        TextureMap textureMap = new TextureMap().put(ALL, Identifier.of(
                                textureId.startsWith("cake_wood") ? CakeWood.MOD_ID : "minecraft",
                                "block/" + textureId));
                        Identifier modelId = model.upload(
                                Identifier.of(CakeWood.MOD_ID, modelName),
                                textureMap,
                                generator.modelCollector
                        );
                        // Set the state condition without extra rotation since the model is built in the correct orientation.
                        When condition = When.create()
                                .set(isTop ? CornerCakeWoodBlock.TOP_BITES : CornerCakeWoodBlock.BOTTOM_BITES, bitesValue)
                                .set(isTop ? CornerCakeWoodBlock.TOP_FACING : CornerCakeWoodBlock.BOTTOM_FACING, facing);
                        stateSupplier.with(condition, BlockStateVariant.create()
                                .put(VariantSettings.MODEL, modelId));
                    }
                }
                generator.blockStateCollector.accept(stateSupplier);
            }
        }
    }
}
</file>
<file path="java/ninja/trek/cakewood/CakeWoodRegistry.java">
package ninja.trek.cakewood;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.minecraft.block.Block;
import net.minecraft.block.MapColor;
import net.minecraft.block.piston.PistonBehavior;
import net.minecraft.item.BlockItem;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.sound.BlockSoundGroup;
import net.minecraft.text.Text;
import java.util.HashMap;
import java.util.Map;
public class CakeWoodRegistry {
    // Base CakeWood blocks and items
    public static final CakeWoodBlock CAKE_WOOD_BLOCK = new CakeWoodBlock(createBlockSettings());
    public static final CakeWoodBlock CAKE_WOOD_PLANKS_BLOCK = new CakeWoodBlock(createBlockSettings());
    public static final BlockItem CAKE_WOOD_ITEM = createBlockItem(CAKE_WOOD_BLOCK, "block.cakewood.cake_wood");
    public static final BlockItem CAKE_WOOD_PLANKS_ITEM = createBlockItem(CAKE_WOOD_PLANKS_BLOCK, "block.cakewood.cake_wood_planks");
    // Base CornerCakeWood blocks and items
    public static final CornerCakeWoodBlock CORNER_CAKE_WOOD_BLOCK = new CornerCakeWoodBlock(createBlockSettings());
    public static final CornerCakeWoodBlock CORNER_CAKE_WOOD_PLANKS_BLOCK = new CornerCakeWoodBlock(createBlockSettings());
    public static final BlockItem CORNER_CAKE_WOOD_ITEM = createBlockItem(CORNER_CAKE_WOOD_BLOCK, "block.cakewood.corner_cake_wood");
    public static final BlockItem CORNER_CAKE_WOOD_PLANKS_ITEM = createBlockItem(CORNER_CAKE_WOOD_PLANKS_BLOCK, "block.cakewood.corner_cake_wood_planks");
    // Maps to store variants for CakeWood
    private static final Map<String, CakeWoodBlock> CAKE_WOOD_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CAKE_WOOD_VARIANT_ITEMS = new HashMap<>();
    private static final Map<String, CakeWoodBlock> CAKE_WOOD_PLANK_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CAKE_WOOD_PLANK_VARIANT_ITEMS = new HashMap<>();
    // Maps to store variants for CornerCakeWood
    private static final Map<String, CornerCakeWoodBlock> CORNER_CAKE_WOOD_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CORNER_CAKE_WOOD_VARIANT_ITEMS = new HashMap<>();
    private static final Map<String, CornerCakeWoodBlock> CORNER_CAKE_WOOD_PLANK_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS = new HashMap<>();
    private static FabricBlockSettings createBlockSettings() {
        return FabricBlockSettings.create()
                .mapColor(MapColor.BROWN)
                .strength(0.5f)
                .sounds(BlockSoundGroup.WOOD)
                .nonOpaque()
                .pistonBehavior(PistonBehavior.DESTROY)
                .breakInstantly();
    }
    private static BlockItem createBlockItem(Block block, String translationKey) {
        return new BlockItem(block, new Item.Settings()) {
            @Override
            public Text getName() {
                return Text.translatable(translationKey);
            }
        };
    }
    // Getter methods for CakeWood variants
    public static Map<String, CakeWoodBlock> getAllWoodVariantBlocks() {
        return CAKE_WOOD_VARIANTS;
    }
    public static Map<String, BlockItem> getAllWoodVariantItems() {
        return CAKE_WOOD_VARIANT_ITEMS;
    }
    public static Map<String, CakeWoodBlock> getAllPlankVariantBlocks() {
        return CAKE_WOOD_PLANK_VARIANTS;
    }
    public static Map<String, BlockItem> getAllPlankVariantItems() {
        return CAKE_WOOD_PLANK_VARIANT_ITEMS;
    }
    // Getter methods for CornerCakeWood variants
    public static Map<String, CornerCakeWoodBlock> getAllCornerWoodVariantBlocks() {
        return CORNER_CAKE_WOOD_VARIANTS;
    }
    public static Map<String, BlockItem> getAllCornerWoodVariantItems() {
        return CORNER_CAKE_WOOD_VARIANT_ITEMS;
    }
    public static Map<String, CornerCakeWoodBlock> getAllCornerPlankVariantBlocks() {
        return CORNER_CAKE_WOOD_PLANK_VARIANTS;
    }
    public static Map<String, BlockItem> getAllCornerPlankVariantItems() {
        return CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS;
    }
    public static void register() {
        // Register base CakeWood and CakeWood Planks
        Registry.register(Registries.BLOCK, CakeWood.id("cake_wood"), CAKE_WOOD_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("cake_wood"), CAKE_WOOD_ITEM);
        Registry.register(Registries.BLOCK, CakeWood.id("cake_wood_planks"), CAKE_WOOD_PLANKS_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("cake_wood_planks"), CAKE_WOOD_PLANKS_ITEM);
        // Register base CornerCakeWood and CornerCakeWood Planks
        Registry.register(Registries.BLOCK, CakeWood.id("corner_cake_wood"), CORNER_CAKE_WOOD_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("corner_cake_wood"), CORNER_CAKE_WOOD_ITEM);
        Registry.register(Registries.BLOCK, CakeWood.id("corner_cake_wood_planks"), CORNER_CAKE_WOOD_PLANKS_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("corner_cake_wood_planks"), CORNER_CAKE_WOOD_PLANKS_ITEM);
        // Register all wood variants
        registerVariant("oak", "Oak-Veneered");
        registerVariant("spruce", "Spruce-Veneered");
        registerVariant("birch", "Birch-Veneered");
        registerVariant("jungle", "Jungle-Veneered");
        registerVariant("acacia", "Acacia-Veneered");
        registerVariant("dark_oak", "Dark Oak-Veneered");
        registerVariant("mangrove", "Mangrove-Veneered");
        registerVariant("cherry", "Cherry-Veneered");
        registerVariant("bamboo", "Bamboo-Veneered");
        registerVariant("crimson", "Crimson-Veneered");
        registerVariant("warped", "Warped-Veneered");
    }
    private static void registerVariant(String woodType, String displayName) {
        // Create and register CakeWood variant
        CakeWoodBlock woodBlock = new CakeWoodBlock(createBlockSettings());
        CakeWoodBlock plankBlock = new CakeWoodBlock(createBlockSettings());
        String woodId = woodType + "_veneered_cake_wood";
        String plankId = woodType + "_veneered_cake_wood_planks";
        BlockItem woodItem = createBlockItem(woodBlock, "block.cakewood." + woodId);
        BlockItem plankItem = createBlockItem(plankBlock, "block.cakewood." + plankId);
        // Create and register CornerCakeWood variant
        CornerCakeWoodBlock cornerWoodBlock = new CornerCakeWoodBlock(createBlockSettings());
        CornerCakeWoodBlock cornerPlankBlock = new CornerCakeWoodBlock(createBlockSettings());
        String cornerWoodId = woodType + "_veneered_corner_cake_wood";
        String cornerPlankId = woodType + "_veneered_corner_cake_wood_planks";
        BlockItem cornerWoodItem = createBlockItem(cornerWoodBlock, "block.cakewood." + cornerWoodId);
        BlockItem cornerPlankItem = createBlockItem(cornerPlankBlock, "block.cakewood." + cornerPlankId);
        // Register CakeWood blocks and items
        Registry.register(Registries.BLOCK, CakeWood.id(woodId), woodBlock);
        Registry.register(Registries.ITEM, CakeWood.id(woodId), woodItem);
        Registry.register(Registries.BLOCK, CakeWood.id(plankId), plankBlock);
        Registry.register(Registries.ITEM, CakeWood.id(plankId), plankItem);
        // Register CornerCakeWood blocks and items
        Registry.register(Registries.BLOCK, CakeWood.id(cornerWoodId), cornerWoodBlock);
        Registry.register(Registries.ITEM, CakeWood.id(cornerWoodId), cornerWoodItem);
        Registry.register(Registries.BLOCK, CakeWood.id(cornerPlankId), cornerPlankBlock);
        Registry.register(Registries.ITEM, CakeWood.id(cornerPlankId), cornerPlankItem);
        // Store in maps
        CAKE_WOOD_VARIANTS.put(woodType, woodBlock);
        CAKE_WOOD_VARIANT_ITEMS.put(woodType, woodItem);
        CAKE_WOOD_PLANK_VARIANTS.put(woodType, plankBlock);
        CAKE_WOOD_PLANK_VARIANT_ITEMS.put(woodType, plankItem);
        CORNER_CAKE_WOOD_VARIANTS.put(woodType, cornerWoodBlock);
        CORNER_CAKE_WOOD_VARIANT_ITEMS.put(woodType, cornerWoodItem);
        CORNER_CAKE_WOOD_PLANK_VARIANTS.put(woodType, cornerPlankBlock);
        CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS.put(woodType, cornerPlankItem);
    }
    // Getter methods for specific variants
    public static CakeWoodBlock getWoodVariantBlock(String woodType) {
        return CAKE_WOOD_VARIANTS.get(woodType);
    }
    public static BlockItem getWoodVariantItem(String woodType) {
        return CAKE_WOOD_VARIANT_ITEMS.get(woodType);
    }
    public static CakeWoodBlock getPlankVariantBlock(String woodType) {
        return CAKE_WOOD_PLANK_VARIANTS.get(woodType);
    }
    public static BlockItem getPlankVariantItem(String woodType) {
        return CAKE_WOOD_PLANK_VARIANT_ITEMS.get(woodType);
    }
    public static CornerCakeWoodBlock getCornerWoodVariantBlock(String woodType) {
        return CORNER_CAKE_WOOD_VARIANTS.get(woodType);
    }
    public static BlockItem getCornerWoodVariantItem(String woodType) {
        return CORNER_CAKE_WOOD_VARIANT_ITEMS.get(woodType);
    }
    public static CornerCakeWoodBlock getCornerPlankVariantBlock(String woodType) {
        return CORNER_CAKE_WOOD_PLANK_VARIANTS.get(woodType);
    }
    public static BlockItem getCornerPlankVariantItem(String woodType) {
        return CORNER_CAKE_WOOD_PLANK_VARIANT_ITEMS.get(woodType);
    }
}
</file>
<file path="java/ninja/trek/cakewood/CornerCakeWoodBlock.java">
package ninja.trek.cakewood;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemPlacementContext;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.state.property.EnumProperty;
import net.minecraft.state.property.IntProperty;
import net.minecraft.util.ActionResult;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.BlockView;
import net.minecraft.world.World;
import net.minecraft.world.event.GameEvent;
import net.minecraft.sound.SoundEvents;
import net.minecraft.sound.SoundCategory;
import net.minecraft.util.StringIdentifiable;
public class CornerCakeWoodBlock extends Block {
    public static final int MAX_BITES = 8;
    public static final IntProperty TOP_BITES = IntProperty.of("top_bites", 0, MAX_BITES);
    public static final IntProperty BOTTOM_BITES = IntProperty.of("bottom_bites", 0, MAX_BITES);
    public enum DiagonalDirection implements StringIdentifiable {
        NORTHWEST("northwest"),
        NORTHEAST("northeast"),
        SOUTHWEST("southwest"),
        SOUTHEAST("southeast");
        private final String name;
        DiagonalDirection(String name) {
            this.name = name;
        }
        @Override
        public String asString() {
            return this.name;
        }
        public static DiagonalDirection fromPlayerView(PlayerEntity player, Vec3d hitPos) {
            // Convert yaw to 0-360 range
            float yaw = (player.getYaw() % 360 + 360) % 360;
            // Divide into diagonal regions:
            // NE = 315-45 degrees  (facing northeast)
            // SE = 45-135 degrees  (facing southeast)
            // SW = 135-225 degrees (facing southwest)
            // NW = 225-315 degrees (facing northwest)
            if (yaw >= 315 || yaw < 45) {
                // Player facing NE
                return DiagonalDirection.NORTHEAST;
            } else if (yaw >= 45 && yaw < 135) {
                // Player facing SE
                return DiagonalDirection.SOUTHEAST;
            } else if (yaw >= 135 && yaw < 225) {
                // Player facing SW
                return DiagonalDirection.SOUTHWEST;
            } else {
                // Player facing NW (yaw >= 225 && yaw < 315)
                return DiagonalDirection.NORTHWEST;
            }
        }
    }
    public static final EnumProperty<DiagonalDirection> TOP_FACING =
            EnumProperty.of("top_facing", DiagonalDirection.class);
    public static final EnumProperty<DiagonalDirection> BOTTOM_FACING =
            EnumProperty.of("bottom_facing", DiagonalDirection.class);
    public CornerCakeWoodBlock(Settings settings) {
        super(settings);
        setDefaultState(getStateManager().getDefaultState()
                .with(TOP_BITES, 0)
                .with(BOTTOM_BITES, 0)
                .with(TOP_FACING, DiagonalDirection.NORTHWEST)
                .with(BOTTOM_FACING, DiagonalDirection.NORTHWEST));
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(TOP_BITES, BOTTOM_BITES, TOP_FACING, BOTTOM_FACING);
    }
    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        DiagonalDirection topFacing = state.get(TOP_FACING);
        DiagonalDirection bottomFacing = state.get(BOTTOM_FACING);
        VoxelShape topShape = topBites >= MAX_BITES ? VoxelShapes.empty() :
                getHalfShape(topBites, true, topFacing);
        VoxelShape bottomShape = bottomBites >= MAX_BITES ? VoxelShapes.empty() :
                getHalfShape(bottomBites, false, bottomFacing);
        return VoxelShapes.union(topShape, bottomShape);
    }
    private VoxelShape getHalfShape(int bites, boolean isTop, DiagonalDirection facing) {
        if (bites >= MAX_BITES) {
            return VoxelShapes.empty();
        }
        // Compute how much of the block remains (using a 16pixel grid)
        float biteSize = bites * (16.0f / MAX_BITES);
        float size = 16.0f - biteSize; // in pixels
        float fraction = size / 16.0f; // normalized [0,1]
        float yMin = isTop ? 0.5f : 0.0f;
        float yMax = isTop ? 1.0f : 0.5f;
        return switch (facing) {
            case NORTHWEST -> VoxelShapes.cuboid(
                    0.0f, yMin, 0.0f,
                    fraction, yMax, fraction
            );
            case NORTHEAST -> VoxelShapes.cuboid(
                    1.0f - fraction, yMin, 0.0f,
                    1.0f, yMax, fraction
            );
            case SOUTHEAST -> VoxelShapes.cuboid(
                    1.0f - fraction, yMin, 1.0f - fraction,
                    1.0f, yMax, 1.0f
            );
            case SOUTHWEST -> VoxelShapes.cuboid(
                    0.0f, yMin, 1.0f - fraction,
                    fraction, yMax, 1.0f
            );
        };
    }
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit) {
        if (world.isClient) {
            if (eatCakeWood(world, pos, state, player, hit).isAccepted()) {
                return ActionResult.SUCCESS;
            }
            return ActionResult.CONSUME;
        }
        return eatCakeWood(world, pos, state, player, hit);
    }
    private ActionResult eatCakeWood(World world, BlockPos pos, BlockState state, PlayerEntity player, BlockHitResult hit) {
        if (!player.canConsume(true)) {
            return ActionResult.PASS;
        }
        Vec3d hitPos = hit.getPos().subtract(pos.getX(), pos.getY(), pos.getZ());
        boolean isTopHalf = hitPos.y >= 0.5;
        int topBites = state.get(TOP_BITES);
        int bottomBites = state.get(BOTTOM_BITES);
        DiagonalDirection topFacing = state.get(TOP_FACING);
        DiagonalDirection bottomFacing = state.get(BOTTOM_FACING);
        // Check if the hit position intersects with the remaining cake shape
        if (isTopHalf && !doesPointIntersectHalf(hitPos, topBites, true, topFacing)) {
            if (doesPointIntersectHalf(hitPos, bottomBites, false, bottomFacing)) {
                isTopHalf = false;
            } else {
                return ActionResult.PASS;
            }
        }
        IntProperty bitesProp = isTopHalf ? TOP_BITES : BOTTOM_BITES;
        EnumProperty<DiagonalDirection> facingProp = isTopHalf ? TOP_FACING : BOTTOM_FACING;
        int bites = state.get(bitesProp);
        if (bites >= MAX_BITES) {
            return ActionResult.PASS;
        }
        // Use the new direction logic for the first bite
        DiagonalDirection facing = bites == 0
                ? DiagonalDirection.fromPlayerView(player, hitPos)
                : state.get(facingProp);
        BlockState newState = state.with(bitesProp, bites + 1)
                .with(facingProp, facing);
        world.setBlockState(pos, newState,
                Block.NOTIFY_ALL | Block.REDRAW_ON_MAIN_THREAD | Block.FORCE_STATE);
        if (newState.get(TOP_BITES) >= MAX_BITES &&
                newState.get(BOTTOM_BITES) >= MAX_BITES) {
            world.removeBlock(pos, false);
            world.emitGameEvent(player, GameEvent.BLOCK_DESTROY, pos);
        } else {
            world.emitGameEvent(player, GameEvent.BLOCK_CHANGE, pos);
        }
        player.getHungerManager().add(2, 0.1F);
        // Play eating and breaking sounds
        world.playSound(null, pos,
                SoundEvents.ENTITY_GENERIC_EAT,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        world.playSound(null, pos,
                SoundEvents.BLOCK_WOOD_BREAK,
                SoundCategory.BLOCKS,
                0.5f,
                world.random.nextFloat() * 0.1f + 0.9f
        );
        return ActionResult.SUCCESS;
    }
    private boolean doesPointIntersectHalf(Vec3d point, int bites, boolean isTop, DiagonalDirection facing) {
        if (bites >= MAX_BITES) {
            return false;
        }
        double yMin = isTop ? 0.5 : 0.0;
        double yMax = isTop ? 1.0 : 0.5;
        if (point.y < yMin || point.y > yMax) {
            return false;
        }
        double fraction = 1.0 - ((double) bites / MAX_BITES);
        return switch (facing) {
            case NORTHWEST -> (point.x >= 0.0 && point.x <= fraction) &&
                    (point.z >= 0.0 && point.z <= fraction);
            case NORTHEAST -> (point.x >= 1.0 - fraction && point.x <= 1.0) &&
                    (point.z >= 0.0 && point.z <= fraction);
            case SOUTHEAST -> (point.x >= 1.0 - fraction && point.x <= 1.0) &&
                    (point.z >= 1.0 - fraction && point.z <= 1.0);
            case SOUTHWEST -> (point.x >= 0.0 && point.x <= fraction) &&
                    (point.z >= 1.0 - fraction && point.z <= 1.0);
        };
    }
    @Override
    public BlockState getPlacementState(ItemPlacementContext ctx) {
        // Just return default state - direction will be set on first bite
        return getDefaultState();
    }
    @Override
    public boolean hasComparatorOutput(BlockState state) {
        return true;
    }
    @Override
    public int getComparatorOutput(BlockState state, World world, BlockPos pos) {
        return Math.max(MAX_BITES - state.get(TOP_BITES), MAX_BITES - state.get(BOTTOM_BITES));
    }
}
</file>
<file path="java/ninja/trek/cakewood/mixin/ExampleMixin.java">
package ninja.trek.cakewood.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>
<file path="repomixx - dontignore.bat">
repomix --style xml --remove-empty-lines --copy
</file>
<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "generated/**"
</file>
<file path="resources/assets/cakewood/lang/en_us.json">
{
  "block.cakewood.cake_wood": "CakeWood",
  "block.cakewood.cake_wood_planks": "CakeWood Planks",
  "block.cakewood.corner_cake_wood": "Corner CakeWood",
  "block.cakewood.corner_cake_wood_planks": "Corner CakeWood Planks",
  "block.cakewood.oak_veneered_cake_wood": "Oak-Veneered CakeWood",
  "block.cakewood.oak_veneered_cake_wood_planks": "Oak-Veneered CakeWood Planks",
  "block.cakewood.oak_veneered_corner_cake_wood": "Oak-Veneered Corner CakeWood",
  "block.cakewood.oak_veneered_corner_cake_wood_planks": "Oak-Veneered Corner CakeWood Planks",
  "block.cakewood.spruce_veneered_cake_wood": "Spruce-Veneered CakeWood",
  "block.cakewood.spruce_veneered_cake_wood_planks": "Spruce-Veneered CakeWood Planks",
  "block.cakewood.spruce_veneered_corner_cake_wood": "Spruce-Veneered Corner CakeWood",
  "block.cakewood.spruce_veneered_corner_cake_wood_planks": "Spruce-Veneered Corner CakeWood Planks",
  "block.cakewood.birch_veneered_cake_wood": "Birch-Veneered CakeWood",
  "block.cakewood.birch_veneered_cake_wood_planks": "Birch-Veneered CakeWood Planks",
  "block.cakewood.birch_veneered_corner_cake_wood": "Birch-Veneered Corner CakeWood",
  "block.cakewood.birch_veneered_corner_cake_wood_planks": "Birch-Veneered Corner CakeWood Planks",
  "block.cakewood.jungle_veneered_cake_wood": "Jungle-Veneered CakeWood",
  "block.cakewood.jungle_veneered_cake_wood_planks": "Jungle-Veneered CakeWood Planks",
  "block.cakewood.jungle_veneered_corner_cake_wood": "Jungle-Veneered Corner CakeWood",
  "block.cakewood.jungle_veneered_corner_cake_wood_planks": "Jungle-Veneered Corner CakeWood Planks",
  "block.cakewood.acacia_veneered_cake_wood": "Acacia-Veneered CakeWood",
  "block.cakewood.acacia_veneered_cake_wood_planks": "Acacia-Veneered CakeWood Planks",
  "block.cakewood.acacia_veneered_corner_cake_wood": "Acacia-Veneered Corner CakeWood",
  "block.cakewood.acacia_veneered_corner_cake_wood_planks": "Acacia-Veneered Corner CakeWood Planks",
  "block.cakewood.dark_oak_veneered_cake_wood": "Dark Oak-Veneered CakeWood",
  "block.cakewood.dark_oak_veneered_cake_wood_planks": "Dark Oak-Veneered CakeWood Planks",
  "block.cakewood.dark_oak_veneered_corner_cake_wood": "Dark Oak-Veneered Corner CakeWood",
  "block.cakewood.dark_oak_veneered_corner_cake_wood_planks": "Dark Oak-Veneered Corner CakeWood Planks",
  "block.cakewood.mangrove_veneered_cake_wood": "Mangrove-Veneered CakeWood",
  "block.cakewood.mangrove_veneered_cake_wood_planks": "Mangrove-Veneered CakeWood Planks",
  "block.cakewood.mangrove_veneered_corner_cake_wood": "Mangrove-Veneered Corner CakeWood",
  "block.cakewood.mangrove_veneered_corner_cake_wood_planks": "Mangrove-Veneered Corner CakeWood Planks",
  "block.cakewood.cherry_veneered_cake_wood": "Cherry-Veneered CakeWood",
  "block.cakewood.cherry_veneered_cake_wood_planks": "Cherry-Veneered CakeWood Planks",
  "block.cakewood.cherry_veneered_corner_cake_wood": "Cherry-Veneered Corner CakeWood",
  "block.cakewood.cherry_veneered_corner_cake_wood_planks": "Cherry-Veneered Corner CakeWood Planks",
  "block.cakewood.bamboo_veneered_cake_wood": "Bamboo-Veneered CakeWood",
  "block.cakewood.bamboo_veneered_cake_wood_planks": "Bamboo-Veneered CakeWood Planks",
  "block.cakewood.bamboo_veneered_corner_cake_wood": "Bamboo-Veneered Corner CakeWood",
  "block.cakewood.bamboo_veneered_corner_cake_wood_planks": "Bamboo-Veneered Corner CakeWood Planks",
  "block.cakewood.crimson_veneered_cake_wood": "Crimson-Veneered CakeWood",
  "block.cakewood.crimson_veneered_cake_wood_planks": "Crimson-Veneered CakeWood Planks",
  "block.cakewood.crimson_veneered_corner_cake_wood": "Crimson-Veneered Corner CakeWood",
  "block.cakewood.crimson_veneered_corner_cake_wood_planks": "Crimson-Veneered Corner CakeWood Planks",
  "block.cakewood.warped_veneered_cake_wood": "Warped-Veneered CakeWood",
  "block.cakewood.warped_veneered_cake_wood_planks": "Warped-Veneered CakeWood Planks",
  "block.cakewood.warped_veneered_corner_cake_wood": "Warped-Veneered Corner CakeWood",
  "block.cakewood.warped_veneered_corner_cake_wood_planks": "Warped-Veneered Corner CakeWood Planks"
}
</file>
<file path="resources/assets/cakewood/models/item/cake_wood_item.json">
{
  "parent": "minecraft:item/generated",
  "textures": {
    "layer0": "#texture"
  }
}
</file>
<file path="resources/cakewood.mixins.json">
{
	"required": true,
	"package": "ninja.trek.cakewood.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>
<file path="resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "cakewood",
	"version": "${version}",
	"name": "CakeWood",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/cakewood/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.cakewood.CakeWood"
		],
		"client": [
			"ninja.trek.cakewood.CakeWoodClient"
		],
		"fabric-datagen": [
			"ninja.trek.cakewood.CakeWoodDataGenerator"
		]
	},
	"mixins": [
		"cakewood.mixins.json",
		{
			"config": "cakewood.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>
</files>
</file>

<file path="main/repomixx - dontignore.bat">
repomix --style xml --remove-empty-lines --copy
</file>

<file path="main/repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "generated/**"
</file>

<file path="main/resources/assets/cakewood/lang/en_us.json">
{
  "block.cakewood.cake_wood": "CakeWood",
  "block.cakewood.cake_wood_planks": "CakeWood Planks",
  "block.cakewood.corner_cake_wood": "Corner CakeWood",
  "block.cakewood.corner_cake_wood_planks": "Corner CakeWood Planks",

  "block.cakewood.oak_veneered_cake_wood": "Oak-Veneered CakeWood",
  "block.cakewood.oak_veneered_cake_wood_planks": "Oak-Veneered CakeWood Planks",
  "block.cakewood.oak_veneered_corner_cake_wood": "Oak-Veneered Corner CakeWood",
  "block.cakewood.oak_veneered_corner_cake_wood_planks": "Oak-Veneered Corner CakeWood Planks",

  "block.cakewood.spruce_veneered_cake_wood": "Spruce-Veneered CakeWood",
  "block.cakewood.spruce_veneered_cake_wood_planks": "Spruce-Veneered CakeWood Planks",
  "block.cakewood.spruce_veneered_corner_cake_wood": "Spruce-Veneered Corner CakeWood",
  "block.cakewood.spruce_veneered_corner_cake_wood_planks": "Spruce-Veneered Corner CakeWood Planks",

  "block.cakewood.birch_veneered_cake_wood": "Birch-Veneered CakeWood",
  "block.cakewood.birch_veneered_cake_wood_planks": "Birch-Veneered CakeWood Planks",
  "block.cakewood.birch_veneered_corner_cake_wood": "Birch-Veneered Corner CakeWood",
  "block.cakewood.birch_veneered_corner_cake_wood_planks": "Birch-Veneered Corner CakeWood Planks",

  "block.cakewood.jungle_veneered_cake_wood": "Jungle-Veneered CakeWood",
  "block.cakewood.jungle_veneered_cake_wood_planks": "Jungle-Veneered CakeWood Planks",
  "block.cakewood.jungle_veneered_corner_cake_wood": "Jungle-Veneered Corner CakeWood",
  "block.cakewood.jungle_veneered_corner_cake_wood_planks": "Jungle-Veneered Corner CakeWood Planks",

  "block.cakewood.acacia_veneered_cake_wood": "Acacia-Veneered CakeWood",
  "block.cakewood.acacia_veneered_cake_wood_planks": "Acacia-Veneered CakeWood Planks",
  "block.cakewood.acacia_veneered_corner_cake_wood": "Acacia-Veneered Corner CakeWood",
  "block.cakewood.acacia_veneered_corner_cake_wood_planks": "Acacia-Veneered Corner CakeWood Planks",

  "block.cakewood.dark_oak_veneered_cake_wood": "Dark Oak-Veneered CakeWood",
  "block.cakewood.dark_oak_veneered_cake_wood_planks": "Dark Oak-Veneered CakeWood Planks",
  "block.cakewood.dark_oak_veneered_corner_cake_wood": "Dark Oak-Veneered Corner CakeWood",
  "block.cakewood.dark_oak_veneered_corner_cake_wood_planks": "Dark Oak-Veneered Corner CakeWood Planks",

  "block.cakewood.mangrove_veneered_cake_wood": "Mangrove-Veneered CakeWood",
  "block.cakewood.mangrove_veneered_cake_wood_planks": "Mangrove-Veneered CakeWood Planks",
  "block.cakewood.mangrove_veneered_corner_cake_wood": "Mangrove-Veneered Corner CakeWood",
  "block.cakewood.mangrove_veneered_corner_cake_wood_planks": "Mangrove-Veneered Corner CakeWood Planks",

  "block.cakewood.cherry_veneered_cake_wood": "Cherry-Veneered CakeWood",
  "block.cakewood.cherry_veneered_cake_wood_planks": "Cherry-Veneered CakeWood Planks",
  "block.cakewood.cherry_veneered_corner_cake_wood": "Cherry-Veneered Corner CakeWood",
  "block.cakewood.cherry_veneered_corner_cake_wood_planks": "Cherry-Veneered Corner CakeWood Planks",

  "block.cakewood.bamboo_veneered_cake_wood": "Bamboo-Veneered CakeWood",
  "block.cakewood.bamboo_veneered_cake_wood_planks": "Bamboo-Veneered CakeWood Planks",
  "block.cakewood.bamboo_veneered_corner_cake_wood": "Bamboo-Veneered Corner CakeWood",
  "block.cakewood.bamboo_veneered_corner_cake_wood_planks": "Bamboo-Veneered Corner CakeWood Planks",

  "block.cakewood.crimson_veneered_cake_wood": "Crimson-Veneered CakeWood",
  "block.cakewood.crimson_veneered_cake_wood_planks": "Crimson-Veneered CakeWood Planks",
  "block.cakewood.crimson_veneered_corner_cake_wood": "Crimson-Veneered Corner CakeWood",
  "block.cakewood.crimson_veneered_corner_cake_wood_planks": "Crimson-Veneered Corner CakeWood Planks",

  "block.cakewood.warped_veneered_cake_wood": "Warped-Veneered CakeWood",
  "block.cakewood.warped_veneered_cake_wood_planks": "Warped-Veneered CakeWood Planks",
  "block.cakewood.warped_veneered_corner_cake_wood": "Warped-Veneered Corner CakeWood",
  "block.cakewood.warped_veneered_corner_cake_wood_planks": "Warped-Veneered Corner CakeWood Planks"
}
</file>

<file path="main/resources/assets/cakewood/models/item/cake_wood_item.json">
{
  "parent": "minecraft:item/generated",
  "textures": {
    "layer0": "#texture"
  }
}
</file>

<file path="main/resources/cakewood.mixins.json">
{
	"required": true,
	"package": "ninja.trek.cakewood.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "cakewood",
	"version": "${version}",
	"name": "CakeWood",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/cakewood/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.cakewood.CakeWood"
		],
		"client": [
			"ninja.trek.cakewood.CakeWoodClient"
		],
		"fabric-datagen": [
			"ninja.trek.cakewood.CakeWoodDataGenerator"
		]
	},
	"mixins": [
		"cakewood.mixins.json",
		{
			"config": "cakewood.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

<file path="repomixx - dontignore.bat">
repomix --style xml --remove-empty-lines --copy
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
