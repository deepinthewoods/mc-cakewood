This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-30T18:20:24.407Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
java/ninja/trek/cakewood/CakeWood.java
java/ninja/trek/cakewood/CakeWoodBlock.java
java/ninja/trek/cakewood/CakeWoodClient.java
java/ninja/trek/cakewood/CakeWoodDataGenerator.java
java/ninja/trek/cakewood/CakeWoodRegistry.java
java/ninja/trek/cakewood/mixin/ExampleMixin.java
repomixx.bat
resources/assets/cakewood/models/block/cake_wood_base.json
resources/cakewood.mixins.json
resources/fabric.mod.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="java/ninja/trek/cakewood/CakeWood.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ModInitializer;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class CakeWood implements ModInitializer {
    public static final String MOD_ID = "cakewood";
    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
    @Override
    public void onInitialize() {
        // Register all CakeWood variants
        CakeWoodRegistry.register();
        LOGGER.info("CakeWood Mod Initialized - Let them eat cake... wood!");
    }
    // Utility method to create identifiers for this mod
    public static Identifier id(String path) {
        return Identifier.of(MOD_ID, path);
    }
}
</file>

<file path="java/ninja/trek/cakewood/CakeWoodBlock.java">
package ninja.trek.cakewood;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemPlacementContext;
import net.minecraft.item.ItemStack;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.state.property.IntProperty;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.BlockView;
import net.minecraft.world.World;
import net.minecraft.world.WorldAccess;
import net.minecraft.sound.SoundEvents;
import net.minecraft.sound.SoundCategory;
public class CakeWoodBlock extends Block {
    public static final int MAX_BITES = 7;
    public static final IntProperty TOP_BITES = IntProperty.of("top_bites", 0, MAX_BITES);
    public static final IntProperty BOTTOM_BITES = IntProperty.of("bottom_bites", 0, MAX_BITES);
    public static final DirectionProperty TOP_FACING = DirectionProperty.of("top_facing",
            Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);
    public static final DirectionProperty BOTTOM_FACING = DirectionProperty.of("bottom_facing",
            Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);
    protected static final VoxelShape[] TOP_SHAPES = new VoxelShape[8];
    protected static final VoxelShape[] BOTTOM_SHAPES = new VoxelShape[8];
    static {
        // Define shapes for top half
        for (int i = 0; i < 8; i++) {
            float height = 8.0f - i;
            TOP_SHAPES[i] = VoxelShapes.cuboid(0.0625f, 0.5f, 0.0625f,
                    0.9375f, 0.5f + (height/16.0f), 0.9375f);
        }
        // Define shapes for bottom half
        for (int i = 0; i < 8; i++) {
            float height = 8.0f - i;
            BOTTOM_SHAPES[i] = VoxelShapes.cuboid(0.0625f, 0.0f, 0.0625f,
                    0.9375f, height/16.0f, 0.9375f);
        }
    }
    public CakeWoodBlock(Settings settings) {
        super(settings);
        setDefaultState(getStateManager().getDefaultState()
                .with(TOP_BITES, 0)
                .with(BOTTOM_BITES, 0)
                .with(TOP_FACING, Direction.NORTH)
                .with(BOTTOM_FACING, Direction.NORTH));
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(TOP_BITES, BOTTOM_BITES, TOP_FACING, BOTTOM_FACING);
    }
    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        VoxelShape topShape = TOP_SHAPES[state.get(TOP_BITES)];
        VoxelShape bottomShape = BOTTOM_SHAPES[state.get(BOTTOM_BITES)];
        return VoxelShapes.union(topShape, bottomShape);
    }
    @Override
    protected ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit) {
        if (world.isClient) {
            if (tryEat(world, pos, state, player, hit).isAccepted()) {
                return ActionResult.SUCCESS;
            }
            return ActionResult.CONSUME;
        }
        return tryEat(world, pos, state, player, hit);
    }
    private ActionResult tryEat(World world, BlockPos pos, BlockState state,
                                PlayerEntity player, BlockHitResult hit) {
        if (!player.canConsume(false)) {
            return ActionResult.PASS;
        }
        // Determine which layer was clicked
        boolean isTopLayer = hit.getPos().y - pos.getY() >= 0.5;
        int bites = isTopLayer ? state.get(TOP_BITES) : state.get(BOTTOM_BITES);
        Direction facing = isTopLayer ? state.get(TOP_FACING) : state.get(BOTTOM_FACING);
        // Check if layer is fully eaten
        if (bites >= MAX_BITES) {
            return ActionResult.PASS;
        }
        // Set initial facing based on player position if this is first bite
        if (bites == 0) {
            facing = Direction.fromHorizontal(
                    (int)((player.getYaw() * 4.0f / 360.0f) + 0.5f) & 3
            ).getOpposite();
        }
        // Update the block state
        BlockState newState = state.with(
                isTopLayer ? TOP_BITES : BOTTOM_BITES, bites + 1
        ).with(
                isTopLayer ? TOP_FACING : BOTTOM_FACING, facing
        );
        // Check if both layers are fully eaten
        if (newState.get(TOP_BITES) >= MAX_BITES &&
                newState.get(BOTTOM_BITES) >= MAX_BITES) {
            world.removeBlock(pos, false);
        } else {
            world.setBlockState(pos, newState, Block.NOTIFY_ALL);
        }
        // Apply eating effects
        player.getHungerManager().add(2, 0.1F);
        world.playSound(null, pos, SoundEvents.ENTITY_GENERIC_EAT,
                SoundCategory.BLOCKS, 1.0F, 1.0F);
        return ActionResult.SUCCESS;
    }
    @Override
    public BlockState getPlacementState(ItemPlacementContext ctx) {
        return this.getDefaultState()
                .with(TOP_FACING, ctx.getHorizontalPlayerFacing().getOpposite())
                .with(BOTTOM_FACING, ctx.getHorizontalPlayerFacing().getOpposite());
    }
    @Override
    public boolean hasComparatorOutput(BlockState state) {
        return true;
    }
    @Override
    public int getComparatorOutput(BlockState state, World world, BlockPos pos) {
        return Math.max(7 - state.get(TOP_BITES), 7 - state.get(BOTTOM_BITES));
    }
    @Override
    protected boolean canReplace(BlockState state, ItemPlacementContext context) {
        return super.canReplace(state, context);
    }
}
</file>

<file path="java/ninja/trek/cakewood/CakeWoodClient.java">
package ninja.trek.cakewood;
import net.fabricmc.api.ClientModInitializer;
public class CakeWoodClient implements ClientModInitializer {
    @Override
    public void onInitializeClient() {
        // Register client-side rendering and other client-specific features here
        CakeWood.LOGGER.info("CakeWood Client Initialized");
    }
}
</file>

<file path="java/ninja/trek/cakewood/CakeWoodDataGenerator.java">
package ninja.trek.cakewood;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.fabricmc.fabric.api.datagen.v1.provider.FabricModelProvider;
import net.fabricmc.fabric.api.datagen.v1.provider.FabricRecipeProvider;
import net.minecraft.data.client.*;
import net.minecraft.data.server.recipe.RecipeExporter;
import net.minecraft.data.server.recipe.ShapedRecipeJsonBuilder;
import net.minecraft.item.Item;
import net.minecraft.item.Items;
import net.minecraft.recipe.book.RecipeCategory;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.Direction;
import java.util.concurrent.CompletableFuture;
public class CakeWoodDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        pack.addProvider((output, registriesFuture) -> new CakeWoodModelGenerator(output));
        pack.addProvider((output, registriesFuture) -> new CakeWoodRecipeGenerator(output, registriesFuture));
    }
    private static class CakeWoodModelGenerator extends FabricModelProvider {
        public CakeWoodModelGenerator(FabricDataOutput output) {
            super(output);
        }
        @Override
        public void generateBlockStateModels(BlockStateModelGenerator blockStateModelGenerator) {
            // Register block models and states
            registerBlockModels(blockStateModelGenerator, CakeWoodRegistry.CAKE_WOOD_BLOCK,
                    Identifier.of(CakeWood.MOD_ID, "block/cake_wood"));
            // Register variants for each wood type
            CakeWoodRegistry.getAllVariantBlocks().forEach((woodType, block) -> {
                registerBlockModels(blockStateModelGenerator, block,
                        Identifier.of("minecraft", "block/" + woodType + "_planks"));
            });
        }
        private void registerBlockModels(BlockStateModelGenerator generator, CakeWoodBlock block, Identifier texture) {
            MultipartBlockStateSupplier stateSupplier = MultipartBlockStateSupplier.create(block);
            Identifier modelId = Registries.BLOCK.getId(block);
            // Generate model with textures
            Models.CUBE_ALL.upload(modelId, TextureMap.all(texture), generator.modelCollector);
            for (Direction topFacing : Direction.Type.HORIZONTAL) {
                for (Direction bottomFacing : Direction.Type.HORIZONTAL) {
                    // Calculate rotation based on direction
                    VariantSettings.Rotation rotation = switch ((int) topFacing.asRotation()) {
                        case 90 -> VariantSettings.Rotation.R90;
                        case 180 -> VariantSettings.Rotation.R180;
                        case 270 -> VariantSettings.Rotation.R270;
                        default -> VariantSettings.Rotation.R0;
                    };
                    // Create variant with rotation
                    BlockStateVariant variant = BlockStateVariant.create()
                            .put(VariantSettings.MODEL, modelId)
                            .put(VariantSettings.Y, rotation);
                    // Add variants for each bite state
                    for (int i = 0; i <= 7; i++) {
                        final int topBites = i;
                        for (int j = 0; j <= 7; j++) {
                            final int bottomBites = j;
                            stateSupplier.with(When.create()
                                            .set(CakeWoodBlock.TOP_BITES, topBites)
                                            .set(CakeWoodBlock.BOTTOM_BITES, bottomBites)
                                            .set(CakeWoodBlock.TOP_FACING, topFacing)
                                            .set(CakeWoodBlock.BOTTOM_FACING, bottomFacing),
                                    variant);
                        }
                    }
                }
            }
            generator.blockStateCollector.accept(stateSupplier);
        }
        @Override
        public void generateItemModels(ItemModelGenerator itemModelGenerator) {
            // Generate item model for base CakeWood
            itemModelGenerator.register(CakeWoodRegistry.CAKE_WOOD_ITEM, Models.GENERATED);
            // Generate item models for variants
            CakeWoodRegistry.getAllVariantBlocks().forEach((woodType, block) -> {
                itemModelGenerator.register(CakeWoodRegistry.getVariantBlockItem(woodType),
                        Models.GENERATED);
            });
        }
    }
    private static class CakeWoodRecipeGenerator extends FabricRecipeProvider {
        public CakeWoodRecipeGenerator(FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) {
            super(output, registriesFuture);
        }
        @Override
        public void generate(RecipeExporter exporter) {
            // Base CakeWood recipe
            ShapedRecipeJsonBuilder.create(RecipeCategory.BUILDING_BLOCKS, CakeWoodRegistry.CAKE_WOOD_BLOCK)
                    .pattern("WWW")
                    .pattern("CCC")
                    .pattern("WWW")
                    .input('W', Items.OAK_PLANKS)
                    .input('C', Items.CAKE)
                    .criterion(hasItem(Items.CAKE), conditionsFromItem(Items.CAKE))
                    .criterion(hasItem(Items.OAK_PLANKS), conditionsFromItem(Items.OAK_PLANKS))
                    .offerTo(exporter, Identifier.of(CakeWood.MOD_ID, "cake_wood"));
            // Wood variant recipes
            var woodItems = new Object[][] {
                    {"oak", Items.OAK_PLANKS},
                    {"spruce", Items.SPRUCE_PLANKS},
                    {"birch", Items.BIRCH_PLANKS},
                    {"jungle", Items.JUNGLE_PLANKS},
                    {"acacia", Items.ACACIA_PLANKS},
                    {"dark_oak", Items.DARK_OAK_PLANKS},
                    {"mangrove", Items.MANGROVE_PLANKS},
                    {"cherry", Items.CHERRY_PLANKS},
                    {"bamboo", Items.BAMBOO_PLANKS},
                    {"crimson", Items.CRIMSON_PLANKS},
                    {"warped", Items.WARPED_PLANKS}
            };
            for (Object[] wood : woodItems) {
                String woodType = (String)wood[0];
                Item planks = (Item)wood[1];
                if (CakeWoodRegistry.getVariantBlock(woodType) != null) {
                    ShapedRecipeJsonBuilder.create(RecipeCategory.BUILDING_BLOCKS,
                                    CakeWoodRegistry.getVariantBlock(woodType))
                            .pattern("WWW")
                            .pattern("CCC")
                            .pattern("WWW")
                            .input('W', planks)
                            .input('C', CakeWoodRegistry.CAKE_WOOD_BLOCK)
                            .criterion(hasItem(CakeWoodRegistry.CAKE_WOOD_BLOCK),
                                    conditionsFromItem(CakeWoodRegistry.CAKE_WOOD_BLOCK))
                            .offerTo(exporter, Identifier.of(CakeWood.MOD_ID,
                                    woodType + "_cake_wood"));
                }
            }
        }
    }
}
</file>

<file path="java/ninja/trek/cakewood/CakeWoodRegistry.java">
package ninja.trek.cakewood;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.minecraft.block.Block;
import net.minecraft.block.Blocks;
import net.minecraft.item.BlockItem;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.sound.BlockSoundGroup;
import net.minecraft.util.Identifier;
import java.util.HashMap;
import java.util.Map;
public class CakeWoodRegistry {
    // Base CakeWood block and item
    public static final CakeWoodBlock CAKE_WOOD_BLOCK = new CakeWoodBlock(FabricBlockSettings.create()
            .strength(0.5f)
            .sounds(BlockSoundGroup.WOOD)
            .nonOpaque());
    public static final BlockItem CAKE_WOOD_ITEM = new BlockItem(CAKE_WOOD_BLOCK, new Item.Settings());
    // Wood variants
    private static final Map<String, CakeWoodBlock> CAKE_WOOD_VARIANTS = new HashMap<>();
    private static final Map<String, BlockItem> CAKE_WOOD_VARIANT_ITEMS = new HashMap<>();
    public static void register() {
        // Register base CakeWood
        Registry.register(Registries.BLOCK, CakeWood.id("cake_wood"), CAKE_WOOD_BLOCK);
        Registry.register(Registries.ITEM, CakeWood.id("cake_wood"), CAKE_WOOD_ITEM);
        // Register vanilla wood variants
        registerVariant("oak");
        registerVariant("spruce");
        registerVariant("birch");
        registerVariant("jungle");
        registerVariant("acacia");
        registerVariant("dark_oak");
        registerVariant("mangrove");
        registerVariant("cherry");
        registerVariant("bamboo");
        registerVariant("crimson");
        registerVariant("warped");
    }
    private static void registerVariant(String woodType) {
        CakeWoodBlock block = new CakeWoodBlock(FabricBlockSettings.create()
                .strength(0.5f)
                .sounds(BlockSoundGroup.WOOD)
                .nonOpaque());
        BlockItem blockItem = new BlockItem(block, new Item.Settings());
        Registry.register(Registries.BLOCK,
                CakeWood.id(woodType + "_cake_wood"), block);
        Registry.register(Registries.ITEM,
                CakeWood.id(woodType + "_cake_wood"), blockItem);
        CAKE_WOOD_VARIANTS.put(woodType, block);
        CAKE_WOOD_VARIANT_ITEMS.put(woodType, blockItem);
    }
    public static CakeWoodBlock getVariantBlock(String woodType) {
        return CAKE_WOOD_VARIANTS.get(woodType);
    }
    public static BlockItem getVariantBlockItem(String woodType) {
        return CAKE_WOOD_VARIANT_ITEMS.get(woodType);
    }
    public static Map<String, CakeWoodBlock> getAllVariantBlocks() {
        return CAKE_WOOD_VARIANTS;
    }
}
</file>

<file path="java/ninja/trek/cakewood/mixin/ExampleMixin.java">
package ninja.trek.cakewood.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "generated/**"
</file>

<file path="resources/assets/cakewood/models/block/cake_wood_base.json">
{
  "parent": "block/block",
  "textures": {
    "particle": "#all",
    "all": "#all"
  },
  "elements": [
    {
      "from": [1, 0, 1],
      "to": [15, 8, 15],
      "faces": {
        "north": {"uv": [1, 8, 15, 16], "texture": "#all"},
        "east": {"uv": [1, 8, 15, 16], "texture": "#all"},
        "south": {"uv": [1, 8, 15, 16], "texture": "#all"},
        "west": {"uv": [1, 8, 15, 16], "texture": "#all"},
        "up": {"uv": [1, 1, 15, 15], "texture": "#all"},
        "down": {"uv": [1, 1, 15, 15], "texture": "#all"}
      }
    },
    {
      "from": [1, 8, 1],
      "to": [15, 16, 15],
      "faces": {
        "north": {"uv": [1, 0, 15, 8], "texture": "#all"},
        "east": {"uv": [1, 0, 15, 8], "texture": "#all"},
        "south": {"uv": [1, 0, 15, 8], "texture": "#all"},
        "west": {"uv": [1, 0, 15, 8], "texture": "#all"},
        "up": {"uv": [1, 1, 15, 15], "texture": "#all"},
        "down": {"uv": [1, 1, 15, 15], "texture": "#all"}
      }
    }
  ]
}
</file>

<file path="resources/cakewood.mixins.json">
{
	"required": true,
	"package": "ninja.trek.cakewood.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "cakewood",
	"version": "${version}",
	"name": "CakeWood",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/cakewood/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.cakewood.CakeWood"
		],
		"client": [
			"ninja.trek.cakewood.CakeWoodClient"
		],
		"fabric-datagen": [
			"ninja.trek.cakewood.CakeWoodDataGenerator"
		]
	},
	"mixins": [
		"cakewood.mixins.json",
		{
			"config": "cakewood.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

</files>
